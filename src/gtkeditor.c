/* gtkeditor.c generated by valac 0.10.0, the Vala compiler
 * generated from gtkeditor.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "gtkeditor.h"
#include <Scintilla.h>
#include <SciLexer.h>
#include <ScintillaWidget.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <stdio.h>
#include <pango/pango.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _pango_font_description_free0(var) ((var == NULL) ? NULL : (var = (pango_font_description_free (var), NULL)))

typedef enum  {
	GTK_EDITOR_ERROR_STYLE_KEY_PARSE_ERROR,
	GTK_EDITOR_ERROR_STYLE_VALUE_PARSE_ERROR
} GtkEditorError;
#define GTK_EDITOR_ERROR gtk_editor_error_quark ()
struct _GtkEditorPrivate {
	ScintillaObject* sci;
	gint _fold_margin_color;
	gint _fold_marker_fore_color;
	gint _fold_marker_back_color;
	GtkEditorFoldMarkerStyles _fold_marker_style;
	char* _default_font_desc;
	char* _font_desc;
	gboolean _line_nums_visible;
	char* _text;
};


static gint gtk_editor_FOLD_MARGIN_INDEX;
static gint gtk_editor_FOLD_MARGIN_INDEX = 1;
static GtkIEditorLexer* gtk_editor__lexer;
static GtkIEditorLexer* gtk_editor__lexer = NULL;
static gpointer gtk_editor_parent_class = NULL;

GQuark gtk_editor_error_quark (void);
#define GTK_EDITOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GTK_TYPE_EDITOR, GtkEditorPrivate))
enum  {
	GTK_EDITOR_DUMMY_PROPERTY,
	GTK_EDITOR_LEXER,
	GTK_EDITOR_FOLDING,
	GTK_EDITOR_FOLD_MARGIN_COLOR,
	GTK_EDITOR_FOLD_MARKER_FORE_COLOR,
	GTK_EDITOR_FOLD_MARKER_BACK_COLOR,
	GTK_EDITOR_FOLD_MARKER_STYLE,
	GTK_EDITOR_DEFAULT_FONT_DESC,
	GTK_EDITOR_FONT_SIZE,
	GTK_EDITOR_FONT_DESC,
	GTK_EDITOR_LINE_NUMS_VISIBLE,
	GTK_EDITOR_TEXT,
	GTK_EDITOR_TAB_WIDTH,
	GTK_EDITOR_USE_TABS,
	GTK_EDITOR_TAB_INDENTS,
	GTK_EDITOR_BACKSPACE_UNINDENTS,
	GTK_EDITOR_INDENTATION_GUIDES,
	GTK_EDITOR_HIGHLIGHT_GUIDE
};
static void gtk_editor_on_sci_notify (GtkEditor* self, gint param, struct SCNotification* notif);
static void _gtk_editor_on_sci_notify_scintilla_object_sci_notify (ScintillaObject* _sender, gint param, struct SCNotification* notif, gpointer self);
static void gtk_editor_update_line_nums (GtkEditor* self);
static void gtk_editor_margin_click_handler (GtkEditor* self, gint modifiers, gint position, gint margin);
static void gtk_editor_real_style_needed (GtkEditor* self, gint position);
static void gtk_editor_real_char_added (GtkEditor* self, gint ch);
static void gtk_editor_real_save_point_reached (GtkEditor* self);
static void gtk_editor_real_save_point_left (GtkEditor* self);
static void gtk_editor_real_modify_attempt_ro (GtkEditor* self);
static void gtk_editor_real_key (GtkEditor* self, gint ch, gint modifiers);
static void gtk_editor_real_double_click (GtkEditor* self);
static void gtk_editor_real_update_ui (GtkEditor* self);
static void gtk_editor_real_modified (GtkEditor* self, gint position, gint modificationType, const char* text, gint length, gint linesAdded, gint line, gint foldLevelNow, gint foldLevelPrev);
static void gtk_editor_real_macro_record (GtkEditor* self, gint message, gint wParam, gint lParam);
static void gtk_editor_real_margin_click (GtkEditor* self, gint modifiers, gint position, gint margin);
static void gtk_editor_real_need_shown (GtkEditor* self, gint position, gint length);
static void gtk_editor_real_painted (GtkEditor* self);
static void gtk_editor_real_user_list_selection (GtkEditor* self, gint listType, const char* text);
static void gtk_editor_real_uri_dropped (GtkEditor* self, const char* text);
static void gtk_editor_real_dwell_start (GtkEditor* self, gint position);
static void gtk_editor_real_dwell_end (GtkEditor* self, gint position);
static void gtk_editor_real_zoom (GtkEditor* self);
static void gtk_editor_real_hot_spot_click (GtkEditor* self, gint modifiers, gint position);
static void gtk_editor_real_hot_spot_double_click (GtkEditor* self, gint modifiers, gint position);
static void gtk_editor_real_call_tip_click (GtkEditor* self, gint position);
static void gtk_editor_real_auto_c_selection (GtkEditor* self, const char* text);
static void gtk_editor_real_indicator_click (GtkEditor* self, gint modifiers, gint position);
static void gtk_editor_real_indicator_release (GtkEditor* self, gint modifiers, gint position);
static void gtk_editor_real_auto_c_cancelled (GtkEditor* self);
static void gtk_editor_real_auto_c_char_deleted (GtkEditor* self);
static void gtk_editor_finalize (GObject* obj);
static void gtk_editor_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void gtk_editor_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static void g_cclosure_user_marshal_VOID__INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__INT_INT_STRING_INT_INT_INT_INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__INT_INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__INT_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

GQuark gtk_editor_error_quark (void) {
	return g_quark_from_static_string ("gtk_editor_error-quark");
}


GType gtk_editor_fold_marker_styles_get_type (void) {
	static volatile gsize gtk_editor_fold_marker_styles_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_editor_fold_marker_styles_type_id__volatile)) {
		static const GEnumValue values[] = {{GTK_EDITOR_FOLD_MARKER_STYLES_ARROW, "GTK_EDITOR_FOLD_MARKER_STYLES_ARROW", "arrow"}, {GTK_EDITOR_FOLD_MARKER_STYLES_PLUS_MINUS, "GTK_EDITOR_FOLD_MARKER_STYLES_PLUS_MINUS", "plus-minus"}, {GTK_EDITOR_FOLD_MARKER_STYLES_CIRCLE_TREE, "GTK_EDITOR_FOLD_MARKER_STYLES_CIRCLE_TREE", "circle-tree"}, {GTK_EDITOR_FOLD_MARKER_STYLES_BOX_TREE, "GTK_EDITOR_FOLD_MARKER_STYLES_BOX_TREE", "box-tree"}, {0, NULL, NULL}};
		GType gtk_editor_fold_marker_styles_type_id;
		gtk_editor_fold_marker_styles_type_id = g_enum_register_static ("GtkEditorFoldMarkerStyles", values);
		g_once_init_leave (&gtk_editor_fold_marker_styles_type_id__volatile, gtk_editor_fold_marker_styles_type_id);
	}
	return gtk_editor_fold_marker_styles_type_id__volatile;
}


/**
 * IndentViews:
 * @NONE:			No indentation guides are shown.
 * @REAL:			Indentation guides are shown inside real indentation white space.
 * @LOOKFORWARD:	Indentation guides are shown beyond the actual indentation up to 
 * 					the level of the next non-empty line. If the previous non-empty 
 * 					line was a fold header then indentation guides are shown for one 
 * 					more level of indent than that line. This setting is good for Python.
 * @LOOKBOTH:		Indentation guides are shown beyond the actual indentation up to 
 * 					the level of the next non-empty line or previous non-empty line 
 * 					whichever is the greater. This setting is good for most languages.
 * 
 * There are 4 indentation guide views. #NONE turns the feature 
 * off but the other 3 states determine how far the guides 
 * appear on empty lines.  
 */
GType gtk_editor_indent_views_get_type (void) {
	static volatile gsize gtk_editor_indent_views_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_editor_indent_views_type_id__volatile)) {
		static const GEnumValue values[] = {{GTK_EDITOR_INDENT_VIEWS_NONE, "GTK_EDITOR_INDENT_VIEWS_NONE", "none"}, {GTK_EDITOR_INDENT_VIEWS_REAL, "GTK_EDITOR_INDENT_VIEWS_REAL", "real"}, {GTK_EDITOR_INDENT_VIEWS_LOOKFORWARD, "GTK_EDITOR_INDENT_VIEWS_LOOKFORWARD", "lookforward"}, {GTK_EDITOR_INDENT_VIEWS_LOOKBOTH, "GTK_EDITOR_INDENT_VIEWS_LOOKBOTH", "lookboth"}, {0, NULL, NULL}};
		GType gtk_editor_indent_views_type_id;
		gtk_editor_indent_views_type_id = g_enum_register_static ("GtkEditorIndentViews", values);
		g_once_init_leave (&gtk_editor_indent_views_type_id__volatile, gtk_editor_indent_views_type_id);
	}
	return gtk_editor_indent_views_type_id__volatile;
}


GType gtk_editor_signals_get_type (void) {
	static volatile gsize gtk_editor_signals_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_editor_signals_type_id__volatile)) {
		static const GEnumValue values[] = {{GTK_EDITOR_SIGNALS_STYLE_NEEDED, "GTK_EDITOR_SIGNALS_STYLE_NEEDED", "style-needed"}, {GTK_EDITOR_SIGNALS_CHAR_ADDED, "GTK_EDITOR_SIGNALS_CHAR_ADDED", "char-added"}, {GTK_EDITOR_SIGNALS_SAVE_POINT_REACHED, "GTK_EDITOR_SIGNALS_SAVE_POINT_REACHED", "save-point-reached"}, {GTK_EDITOR_SIGNALS_SAVE_POINT_LEFT, "GTK_EDITOR_SIGNALS_SAVE_POINT_LEFT", "save-point-left"}, {GTK_EDITOR_SIGNALS_MODIFY_ATTEMPT_R_O, "GTK_EDITOR_SIGNALS_MODIFY_ATTEMPT_R_O", "modify-attempt-r-o"}, {GTK_EDITOR_SIGNALS_KEY, "GTK_EDITOR_SIGNALS_KEY", "key"}, {GTK_EDITOR_SIGNALS_DOUBLE_CLICK, "GTK_EDITOR_SIGNALS_DOUBLE_CLICK", "double-click"}, {GTK_EDITOR_SIGNALS_UPDATE_UI, "GTK_EDITOR_SIGNALS_UPDATE_UI", "update-ui"}, {GTK_EDITOR_SIGNALS_MODIFIED, "GTK_EDITOR_SIGNALS_MODIFIED", "modified"}, {GTK_EDITOR_SIGNALS_MACRO_RECORD, "GTK_EDITOR_SIGNALS_MACRO_RECORD", "macro-record"}, {GTK_EDITOR_SIGNALS_MARGIN_CLICK, "GTK_EDITOR_SIGNALS_MARGIN_CLICK", "margin-click"}, {GTK_EDITOR_SIGNALS_NEED_SHOWN, "GTK_EDITOR_SIGNALS_NEED_SHOWN", "need-shown"}, {GTK_EDITOR_SIGNALS_PAINTED, "GTK_EDITOR_SIGNALS_PAINTED", "painted"}, {GTK_EDITOR_SIGNALS_USER_LIST_SELECTION, "GTK_EDITOR_SIGNALS_USER_LIST_SELECTION", "user-list-selection"}, {GTK_EDITOR_SIGNALS_URI_DROPPED, "GTK_EDITOR_SIGNALS_URI_DROPPED", "uri-dropped"}, {GTK_EDITOR_SIGNALS_DWELL_START, "GTK_EDITOR_SIGNALS_DWELL_START", "dwell-start"}, {GTK_EDITOR_SIGNALS_DWELL_END, "GTK_EDITOR_SIGNALS_DWELL_END", "dwell-end"}, {GTK_EDITOR_SIGNALS_ZOOM, "GTK_EDITOR_SIGNALS_ZOOM", "zoom"}, {GTK_EDITOR_SIGNALS_HOT_SPOT_CLICK, "GTK_EDITOR_SIGNALS_HOT_SPOT_CLICK", "hot-spot-click"}, {GTK_EDITOR_SIGNALS_HOT_SPOT_DOUBLE_CLICK, "GTK_EDITOR_SIGNALS_HOT_SPOT_DOUBLE_CLICK", "hot-spot-double-click"}, {GTK_EDITOR_SIGNALS_CALL_TIP_CLICK, "GTK_EDITOR_SIGNALS_CALL_TIP_CLICK", "call-tip-click"}, {GTK_EDITOR_SIGNALS_AUTO_C_SELECTION, "GTK_EDITOR_SIGNALS_AUTO_C_SELECTION", "auto-c-selection"}, {GTK_EDITOR_SIGNALS_INDICATOR_CLICK, "GTK_EDITOR_SIGNALS_INDICATOR_CLICK", "indicator-click"}, {GTK_EDITOR_SIGNALS_INDICATOR_RELEASE, "GTK_EDITOR_SIGNALS_INDICATOR_RELEASE", "indicator-release"}, {GTK_EDITOR_SIGNALS_AUTO_C_CANCELLED, "GTK_EDITOR_SIGNALS_AUTO_C_CANCELLED", "auto-c-cancelled"}, {GTK_EDITOR_SIGNALS_AUTO_C_CHAR_DELETED, "GTK_EDITOR_SIGNALS_AUTO_C_CHAR_DELETED", "auto-c-char-deleted"}, {GTK_EDITOR_SIGNALS_HOT_SPOT_RELEASE_CLICK, "GTK_EDITOR_SIGNALS_HOT_SPOT_RELEASE_CLICK", "hot-spot-release-click"}, {0, NULL, NULL}};
		GType gtk_editor_signals_type_id;
		gtk_editor_signals_type_id = g_enum_register_static ("GtkEditorSignals", values);
		g_once_init_leave (&gtk_editor_signals_type_id__volatile, gtk_editor_signals_type_id);
	}
	return gtk_editor_signals_type_id__volatile;
}


static void _gtk_editor_on_sci_notify_scintilla_object_sci_notify (ScintillaObject* _sender, gint param, struct SCNotification* notif, gpointer self) {
	gtk_editor_on_sci_notify (self, param, notif);
}


GtkEditor* gtk_editor_construct (GType object_type) {
	GtkEditor * self;
	ScintillaObject* _tmp0_;
	GtkPerlLexer* _tmp1_;
	gboolean fold = FALSE;
	self = g_object_newv (object_type, 0, NULL);
	self->priv->sci = (_tmp0_ = g_object_ref_sink ((ScintillaObject*) scintilla_new ()), _g_object_unref0 (self->priv->sci), _tmp0_);
	gtk_widget_set_size_request ((GtkWidget*) self->priv->sci, 1, 1);
	gtk_editor_set_lexer (self, (GtkIEditorLexer*) (_tmp1_ = gtk_perl_lexer_new (self->priv->sci)));
	_g_object_unref0 (_tmp1_);
	gtk_ieditor_lexer_read_config (gtk_editor_get_lexer (self), "data/config/perl.conf");
	gtk_ieditor_lexer_get_prop_as_bool (gtk_editor_get_lexer (self), "fold", &fold);
	if (fold) {
		gtk_editor_set_folding (self, TRUE);
	}
	gtk_editor_set_fold_marker_style (self, GTK_EDITOR_FOLD_MARKER_STYLES_ARROW);
	gtk_editor_set_fold_marker_fore_color (self, 0xffffff);
	gtk_editor_set_fold_marker_back_color (self, 0x000000);
	gtk_editor_set_font_desc (self, "Monospace 9");
	gtk_editor_set_line_nums_visible (self, TRUE);
	gtk_editor_set_tab_width (self, 4);
	gtk_editor_set_text (self, "#!/usr/local/bin/perl\n" \
" print \"Content-type: text/html\\n\\n\";\n" \
" print \"Hello World.\\n\";\n" \
" print \"Heres the form info:<P>\\n\";\n" \
" my($buffer);\n" \
" my(@pairs);\n" \
" my($pair);\n" \
" read(STDIN,$buffer,$ENV{'CONTENT_LENGTH'});\n" \
" @pairs = split(/&/, $buffer);\n" \
" foreach $pair (@pairs)\n" \
"   {\n" \
"   print \"$pair<BR>\\n\"\n" \
"   }\n" \
"print \"<P>Note that further parsing is\\n\";\n" \
"print \"necessary to turn the plus signs\\n\";\n" \
"print \"into spaces and get rid of some\\n\";\n" \
"print \"other web encoding.\\n\";\n" \
"\t\t\n" \
"\t\t\t");
	g_signal_connect_object (self->priv->sci, "sci-notify", (GCallback) _gtk_editor_on_sci_notify_scintilla_object_sci_notify, self, 0);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->sci);
	return self;
}


GtkEditor* gtk_editor_new (void) {
	return gtk_editor_construct (GTK_TYPE_EDITOR);
}


static void gtk_editor_update_line_nums (GtkEditor* self) {
	g_return_if_fail (self != NULL);
	if (gtk_editor_get_line_nums_visible (self)) {
		gint lines;
		char* tmp_str;
		gint width;
		lines = (gint) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETLINECOUNT, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
		tmp_str = g_strdup_printf ("__%d", lines);
		width = (gint) scintilla_send_message (self->priv->sci, (unsigned int) SCI_TEXTWIDTH, (uptr_t) ((gulong) STYLE_LINENUMBER), (sptr_t) ((glong) tmp_str));
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETMARGINWIDTHN, (uptr_t) ((gulong) 0), (sptr_t) ((glong) width));
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETMARGINSENSITIVEN, (uptr_t) ((gulong) 0), (sptr_t) ((glong) FALSE));
		_g_free0 (tmp_str);
	} else {
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETMARGINWIDTHN, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	}
}


void gtk_editor_set_style_state (GtkEditor* self, int state, GtkEditorStyle* style) {
	g_return_if_fail (self != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_STYLESETFORE, (uptr_t) ((gulong) state), (sptr_t) ((glong) (*style).fg_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_STYLESETBACK, (uptr_t) ((gulong) state), (sptr_t) ((glong) (*style).bg_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_STYLESETBOLD, (uptr_t) ((gulong) state), (sptr_t) ((glong) (*style).bold));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_STYLESETITALIC, (uptr_t) ((gulong) state), (sptr_t) ((glong) (*style).italic));
}


void gtk_editor_clear_styles (GtkEditor* self) {
	g_return_if_fail (self != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_STYLECLEARALL, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
}


/**
 * insert_text:
 * @position:	The position to insert the text at.
 * @text:		The text to insert.
 * 
 * Inserts text at a given character position, starting at 0.
 */
void gtk_editor_insert_text (GtkEditor* self, gint position, const char* text) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_INSERTTEXT, (uptr_t) ((gulong) position), (sptr_t) ((glong) text));
}


/**
 * set_line_indentation:
 * @line:	The line to set the indentation of.
 * @indentation:	The amount of indentation to set.
 * 
 * The indentation is measured in character columns, which
 * correspond to the width of space characters.
 */
void gtk_editor_set_line_indentation (GtkEditor* self, gint line, gint indentation) {
	g_return_if_fail (self != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETLINEINDENTATION, (uptr_t) ((gulong) line), (sptr_t) ((glong) indentation));
}


/** 
 * get_line_indentation:
 * @line: The to get the indentation of.
 * 
 * The indentation is measured in character columns, which
 * correspond to the width of space characters.
 */
gint gtk_editor_get_line_indentation (GtkEditor* self, gint line) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	result = (gint) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETLINEINDENTATION, (uptr_t) ((gulong) line), (sptr_t) ((glong) 0));
	return result;
}


/**
 * get_line_indent_position:
 * @line:	The line to get the indent position of.
 * 
 * This returns the position at the end of indentation of a line.
 */
gint gtk_editor_get_line_indent_position (GtkEditor* self, gint line) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	result = (gint) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETLINEINDENTPOSITION, (uptr_t) ((gulong) line), (sptr_t) ((glong) 0));
	return result;
}


static void gtk_editor_margin_click_handler (GtkEditor* self, gint modifiers, gint position, gint margin) {
	g_return_if_fail (self != NULL);
	if (gtk_editor_get_folding (self)) {
		gint line;
		line = (gint) scintilla_send_message (self->priv->sci, (unsigned int) SCI_LINEFROMPOSITION, (uptr_t) ((gulong) position), (sptr_t) ((glong) 0));
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_TOGGLEFOLD, (uptr_t) ((gulong) line), (sptr_t) ((glong) 0));
	}
}


static void gtk_editor_on_sci_notify (GtkEditor* self, gint param, struct SCNotification* notif) {
	struct SCNotification* n;
	g_return_if_fail (self != NULL);
	n = (struct SCNotification*) notif;
	switch ((*n).nmhdr.code) {
		case SCN_STYLENEEDED:
		{
			g_signal_emit_by_name (self, "style-needed", (*n).position);
			break;
		}
		case SCN_CHARADDED:
		{
			g_signal_emit_by_name (self, "char-added", (*n).ch);
			break;
		}
		case SCN_SAVEPOINTREACHED:
		{
			g_signal_emit_by_name (self, "save-point-reached");
			break;
		}
		case SCN_SAVEPOINTLEFT:
		{
			g_signal_emit_by_name (self, "save-point-left");
			break;
		}
		case SCN_MODIFYATTEMPTRO:
		{
			g_signal_emit_by_name (self, "modify-attempt-ro");
			break;
		}
		case SCN_KEY:
		{
			g_signal_emit_by_name (self, "key", (*n).ch, (*n).modifiers);
			break;
		}
		case SCN_DOUBLECLICK:
		{
			g_signal_emit_by_name (self, "double-click");
			break;
		}
		case SCN_UPDATEUI:
		{
			g_signal_emit_by_name (self, "update-ui");
			break;
		}
		case SCN_MODIFIED:
		{
			g_signal_emit_by_name (self, "modified", (*n).position, (*n).modificationType, (*n).text, (*n).length, (*n).linesAdded, (*n).line, (*n).foldLevelNow, (*n).foldLevelPrev);
			break;
		}
		case SCN_MACRORECORD:
		{
			g_signal_emit_by_name (self, "macro-record", (*n).message, (gint) (*n).wParam, (gint) (*n).lParam);
			break;
		}
		case SCN_MARGINCLICK:
		{
			g_signal_emit_by_name (self, "margin-click", (*n).modifiers, (*n).position, (*n).margin);
			break;
		}
		case SCN_NEEDSHOWN:
		{
			g_signal_emit_by_name (self, "need-shown", (*n).position, (*n).length);
			break;
		}
		case SCN_PAINTED:
		{
			g_signal_emit_by_name (self, "painted");
			break;
		}
		case SCN_USERLISTSELECTION:
		{
			g_signal_emit_by_name (self, "user-list-selection", (*n).listType, (*n).text);
			break;
		}
		case SCN_URIDROPPED:
		{
			g_signal_emit_by_name (self, "uri-dropped", (*n).text);
			break;
		}
		case SCN_DWELLSTART:
		{
			g_signal_emit_by_name (self, "dwell-start", (*n).position);
			break;
		}
		case SCN_DWELLEND:
		{
			g_signal_emit_by_name (self, "dwell-end", (*n).position);
			break;
		}
		case SCN_ZOOM:
		{
			g_signal_emit_by_name (self, "zoom");
			break;
		}
		case SCN_HOTSPOTCLICK:
		{
			g_signal_emit_by_name (self, "hot-spot-click", (*n).modifiers, (*n).position);
			break;
		}
		case SCN_HOTSPOTDOUBLECLICK:
		{
			g_signal_emit_by_name (self, "hot-spot-double-click", (*n).modifiers, (*n).position);
			break;
		}
		case SCN_CALLTIPCLICK:
		{
			g_signal_emit_by_name (self, "call-tip-click", (*n).position);
			break;
		}
		case SCN_AUTOCSELECTION:
		{
			g_signal_emit_by_name (self, "auto-c-selection", (*n).text);
			break;
		}
		case SCN_INDICATORCLICK:
		{
			g_signal_emit_by_name (self, "indicator-click", (*n).modifiers, (*n).position);
			break;
		}
		case SCN_INDICATORRELEASE:
		{
			g_signal_emit_by_name (self, "indicator-release", (*n).modifiers, (*n).position);
			break;
		}
		case SCN_AUTOCCANCELLED:
		{
			g_signal_emit_by_name (self, "auto-c-cancelled");
			break;
		}
		case SCN_AUTOCCHARDELETED:
		{
			g_signal_emit_by_name (self, "auto-c-char-deleted");
			break;
		}
		default:
		{
			fprintf (stdout, "** Unhandled signal code %d\n", (gint) (*n).nmhdr.code);
			break;
		}
	}
}


GtkIEditorLexer* gtk_editor_get_lexer (GtkEditor* self) {
	GtkIEditorLexer* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = gtk_editor__lexer;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void gtk_editor_set_lexer (GtkEditor* self, GtkIEditorLexer* value) {
	GtkIEditorLexer* _tmp0_;
	g_return_if_fail (self != NULL);
	gtk_editor__lexer = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (gtk_editor__lexer), _tmp0_);
	g_object_notify ((GObject *) self, "lexer");
}


gboolean gtk_editor_get_folding (GtkEditor* self) {
	gboolean result;
	gboolean doing_folding = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool (gtk_editor_get_lexer (self), "fold", &doing_folding);
	result = doing_folding;
	return result;
}


void gtk_editor_set_folding (GtkEditor* self, gboolean value) {
	const char* _tmp0_;
	char* fold;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	fold = g_strdup (_tmp0_);
	if (value) {
		_tmp1_ = gtk_ieditor_lexer_set_prop (gtk_editor_get_lexer (self), "fold", fold);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETMARGINTYPEN, (uptr_t) ((gulong) gtk_editor_FOLD_MARGIN_INDEX), (sptr_t) ((glong) SC_MARGIN_SYMBOL));
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETMARGINMASKN, (uptr_t) ((gulong) gtk_editor_FOLD_MARGIN_INDEX), (sptr_t) ((glong) SC_MASK_FOLDERS));
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETMARGINWIDTHN, (uptr_t) ((gulong) gtk_editor_FOLD_MARGIN_INDEX), (sptr_t) ((glong) 16));
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETFOLDFLAGS, (uptr_t) ((gulong) SC_FOLDFLAG_LINEAFTER_CONTRACTED), (sptr_t) ((glong) 0));
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETMARGINSENSITIVEN, (uptr_t) ((gulong) gtk_editor_FOLD_MARGIN_INDEX), (sptr_t) ((glong) 1));
		gtk_editor_update_line_nums (self);
	} else {
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETMARGINWIDTHN, (uptr_t) ((gulong) gtk_editor_FOLD_MARGIN_INDEX), (sptr_t) ((glong) 0));
		scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETMARGINSENSITIVEN, (uptr_t) ((gulong) gtk_editor_FOLD_MARGIN_INDEX), (sptr_t) ((glong) 0));
	}
	_g_free0 (fold);
	g_object_notify ((GObject *) self, "folding");
}


gint gtk_editor_get_fold_margin_color (GtkEditor* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_fold_margin_color;
	return result;
}


void gtk_editor_set_fold_margin_color (GtkEditor* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_fold_margin_color = value;
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETFOLDMARGINCOLOUR, (uptr_t) ((gulong) 1), (sptr_t) ((glong) self->priv->_fold_margin_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETFOLDMARGINHICOLOUR, (uptr_t) ((gulong) 1), (sptr_t) ((glong) self->priv->_fold_margin_color));
	g_object_notify ((GObject *) self, "fold-margin-color");
}


gint gtk_editor_get_fold_marker_fore_color (GtkEditor* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_fold_marker_fore_color;
	return result;
}


void gtk_editor_set_fold_marker_fore_color (GtkEditor* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_fold_marker_fore_color = value;
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETFORE, (uptr_t) ((gulong) SC_MARKNUM_FOLDER), (sptr_t) ((glong) self->priv->_fold_marker_fore_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETFORE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPEN), (sptr_t) ((glong) self->priv->_fold_marker_fore_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETFORE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEREND), (sptr_t) ((glong) self->priv->_fold_marker_fore_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETFORE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERMIDTAIL), (sptr_t) ((glong) self->priv->_fold_marker_fore_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETFORE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPENMID), (sptr_t) ((glong) self->priv->_fold_marker_fore_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETFORE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERSUB), (sptr_t) ((glong) self->priv->_fold_marker_fore_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETFORE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERTAIL), (sptr_t) ((glong) self->priv->_fold_marker_fore_color));
	g_object_notify ((GObject *) self, "fold-marker-fore-color");
}


gint gtk_editor_get_fold_marker_back_color (GtkEditor* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_fold_marker_back_color;
	return result;
}


void gtk_editor_set_fold_marker_back_color (GtkEditor* self, gint value) {
	g_return_if_fail (self != NULL);
	self->priv->_fold_marker_back_color = value;
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETBACK, (uptr_t) ((gulong) SC_MARKNUM_FOLDER), (sptr_t) ((glong) self->priv->_fold_marker_back_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETBACK, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPEN), (sptr_t) ((glong) self->priv->_fold_marker_back_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETBACK, (uptr_t) ((gulong) SC_MARKNUM_FOLDEREND), (sptr_t) ((glong) self->priv->_fold_marker_back_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETBACK, (uptr_t) ((gulong) SC_MARKNUM_FOLDERMIDTAIL), (sptr_t) ((glong) self->priv->_fold_marker_back_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETBACK, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPENMID), (sptr_t) ((glong) self->priv->_fold_marker_back_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETBACK, (uptr_t) ((gulong) SC_MARKNUM_FOLDERSUB), (sptr_t) ((glong) self->priv->_fold_marker_back_color));
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERSETBACK, (uptr_t) ((gulong) SC_MARKNUM_FOLDERTAIL), (sptr_t) ((glong) self->priv->_fold_marker_back_color));
	g_object_notify ((GObject *) self, "fold-marker-back-color");
}


GtkEditorFoldMarkerStyles gtk_editor_get_fold_marker_style (GtkEditor* self) {
	GtkEditorFoldMarkerStyles result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_fold_marker_style;
	return result;
}


void gtk_editor_set_fold_marker_style (GtkEditor* self, GtkEditorFoldMarkerStyles value) {
	g_return_if_fail (self != NULL);
	self->priv->_fold_marker_style = value;
	switch (self->priv->_fold_marker_style) {
		case GTK_EDITOR_FOLD_MARKER_STYLES_PLUS_MINUS:
		{
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDER), (sptr_t) ((glong) SC_MARK_MINUS));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPEN), (sptr_t) ((glong) SC_MARK_PLUS));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEREND), (sptr_t) ((glong) SC_MARK_EMPTY));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERMIDTAIL), (sptr_t) ((glong) SC_MARK_EMPTY));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPENMID), (sptr_t) ((glong) SC_MARK_EMPTY));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERSUB), (sptr_t) ((glong) SC_MARK_EMPTY));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERTAIL), (sptr_t) ((glong) SC_MARK_EMPTY));
			break;
		}
		case GTK_EDITOR_FOLD_MARKER_STYLES_ARROW:
		{
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDER), (sptr_t) ((glong) SC_MARK_ARROWDOWN));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPEN), (sptr_t) ((glong) SC_MARK_ARROW));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEREND), (sptr_t) ((glong) SC_MARK_EMPTY));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERMIDTAIL), (sptr_t) ((glong) SC_MARK_EMPTY));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPENMID), (sptr_t) ((glong) SC_MARK_EMPTY));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERSUB), (sptr_t) ((glong) SC_MARK_EMPTY));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERTAIL), (sptr_t) ((glong) SC_MARK_EMPTY));
			break;
		}
		case GTK_EDITOR_FOLD_MARKER_STYLES_CIRCLE_TREE:
		{
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDER), (sptr_t) ((glong) SC_MARK_CIRCLEPLUS));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPEN), (sptr_t) ((glong) SC_MARK_CIRCLEMINUS));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEREND), (sptr_t) ((glong) SC_MARK_CIRCLEPLUSCONNECTED));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERMIDTAIL), (sptr_t) ((glong) SC_MARK_TCORNERCURVE));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPENMID), (sptr_t) ((glong) SC_MARK_CIRCLEMINUSCONNECTED));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERSUB), (sptr_t) ((glong) SC_MARK_VLINE));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERTAIL), (sptr_t) ((glong) SC_MARK_LCORNERCURVE));
			break;
		}
		default:
		{
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDER), (sptr_t) ((glong) SC_MARK_BOXPLUS));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPEN), (sptr_t) ((glong) SC_MARK_BOXMINUS));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEREND), (sptr_t) ((glong) SC_MARK_BOXPLUSCONNECTED));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERMIDTAIL), (sptr_t) ((glong) SC_MARK_TCORNER));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDEROPENMID), (sptr_t) ((glong) SC_MARK_BOXMINUSCONNECTED));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERSUB), (sptr_t) ((glong) SC_MARK_VLINE));
			scintilla_send_message (self->priv->sci, (unsigned int) SCI_MARKERDEFINE, (uptr_t) ((gulong) SC_MARKNUM_FOLDERTAIL), (sptr_t) ((glong) SC_MARK_LCORNER));
			break;
		}
	}
	g_object_notify ((GObject *) self, "fold-marker-style");
}


const char* gtk_editor_get_default_font_desc (GtkEditor* self) {
	const char* result;
	GtkSettings* settings;
	char* _tmp0_ = NULL;
	char* font_desc;
	PangoFontDescription* pfd;
	gint size;
	char* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	settings = _g_object_ref0 (gtk_settings_get_default ());
	font_desc = (g_object_get (settings, "gtk-font-name", &_tmp0_, NULL), _tmp0_);
	pfd = pango_font_description_from_string (font_desc);
	size = pango_font_description_get_size (pfd) / PANGO_SCALE;
	self->priv->_default_font_desc = (_tmp1_ = g_strdup_printf ("Monospace %d", size), _g_free0 (self->priv->_default_font_desc), _tmp1_);
	result = self->priv->_default_font_desc;
	_pango_font_description_free0 (pfd);
	_g_free0 (font_desc);
	_g_object_unref0 (settings);
	return result;
}


gint gtk_editor_get_font_size (GtkEditor* self) {
	gint result;
	PangoFontDescription* pfd;
	gint size;
	g_return_val_if_fail (self != NULL, 0);
	pfd = pango_font_description_from_string (gtk_editor_get_font_desc (self));
	size = pango_font_description_get_size (pfd) / PANGO_SCALE;
	result = size;
	_pango_font_description_free0 (pfd);
	return result;
}


void gtk_editor_set_font_size (GtkEditor* self, gint value) {
	g_return_if_fail (self != NULL);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < 127)) {
					break;
				}
				scintilla_send_message (self->priv->sci, (unsigned int) SCI_STYLESETSIZE, (uptr_t) ((gulong) i), (sptr_t) ((glong) value));
			}
		}
	}
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETZOOM, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	gtk_editor_update_line_nums (self);
	g_object_notify ((GObject *) self, "font-size");
}


const char* gtk_editor_get_font_desc (GtkEditor* self) {
	const char* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_font_desc;
	return result;
}


void gtk_editor_set_font_desc (GtkEditor* self, const char* value) {
	char* _tmp0_;
	PangoFontDescription* pfd;
	gint size;
	char* font_name;
	g_return_if_fail (self != NULL);
	self->priv->_font_desc = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_font_desc), _tmp0_);
	pfd = pango_font_description_from_string (self->priv->_font_desc);
	size = pango_font_description_get_size (pfd) / PANGO_SCALE;
	font_name = g_strdup_printf ("!%s", pango_font_description_get_family (pfd));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < 127)) {
					break;
				}
				scintilla_send_message (self->priv->sci, (unsigned int) SCI_STYLESETFONT, (uptr_t) ((gulong) i), (sptr_t) ((glong) font_name));
				scintilla_send_message (self->priv->sci, (unsigned int) SCI_STYLESETSIZE, (uptr_t) ((gulong) i), (sptr_t) ((glong) size));
			}
		}
	}
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETZOOM, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	gtk_editor_update_line_nums (self);
	_g_free0 (font_name);
	_pango_font_description_free0 (pfd);
	g_object_notify ((GObject *) self, "font-desc");
}


gboolean gtk_editor_get_line_nums_visible (GtkEditor* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_line_nums_visible;
	return result;
}


void gtk_editor_set_line_nums_visible (GtkEditor* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_line_nums_visible = value;
	gtk_editor_update_line_nums (self);
	g_object_notify ((GObject *) self, "line-nums-visible");
}


const char* gtk_editor_get_text (GtkEditor* self) {
	const char* result;
	gint length;
	gchar* buf;
	char* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	length = (gint) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETLENGTH, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	buf = g_malloc ((gsize) length);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETTEXT, (uptr_t) ((gulong) length), (sptr_t) ((glong) buf));
	self->priv->_text = (_tmp0_ = g_strdup ((const char*) buf), _g_free0 (self->priv->_text), _tmp0_);
	g_free (buf);
	result = self->priv->_text;
	return result;
}


void gtk_editor_set_text (GtkEditor* self, const char* value) {
	g_return_if_fail (self != NULL);
	gtk_editor_insert_text (self, 0, value);
	g_object_notify ((GObject *) self, "text");
}


gint gtk_editor_get_tab_width (GtkEditor* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = (gint) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETTABWIDTH, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	return result;
}


void gtk_editor_set_tab_width (GtkEditor* self, gint value) {
	g_return_if_fail (self != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETTABWIDTH, (uptr_t) ((gulong) value), (sptr_t) ((glong) 0));
	g_object_notify ((GObject *) self, "tab-width");
}


gboolean gtk_editor_get_use_tabs (GtkEditor* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = (gboolean) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETUSETABS, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	return result;
}


void gtk_editor_set_use_tabs (GtkEditor* self, gboolean value) {
	g_return_if_fail (self != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETUSETABS, (uptr_t) ((gulong) value), (sptr_t) ((glong) 0));
	g_object_notify ((GObject *) self, "use-tabs");
}


gboolean gtk_editor_get_tab_indents (GtkEditor* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = (gboolean) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETTABINDENTS, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	return result;
}


void gtk_editor_set_tab_indents (GtkEditor* self, gboolean value) {
	g_return_if_fail (self != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETTABINDENTS, (uptr_t) ((gulong) value), (sptr_t) ((glong) 0));
	g_object_notify ((GObject *) self, "tab-indents");
}


gboolean gtk_editor_get_backspace_unindents (GtkEditor* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = (gboolean) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETBACKSPACEUNINDENTS, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	return result;
}


void gtk_editor_set_backspace_unindents (GtkEditor* self, gboolean value) {
	g_return_if_fail (self != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETBACKSPACEUNINDENTS, (uptr_t) ((gulong) value), (sptr_t) ((glong) 0));
	g_object_notify ((GObject *) self, "backspace-unindents");
}


GtkEditorIndentViews gtk_editor_get_indentation_guides (GtkEditor* self) {
	GtkEditorIndentViews result;
	g_return_val_if_fail (self != NULL, 0);
	result = (GtkEditorIndentViews) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETINDENTATIONGUIDES, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	return result;
}


void gtk_editor_set_indentation_guides (GtkEditor* self, GtkEditorIndentViews value) {
	g_return_if_fail (self != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETINDENTATIONGUIDES, (uptr_t) ((gulong) value), (sptr_t) ((glong) 0));
	g_object_notify ((GObject *) self, "indentation-guides");
}


gint gtk_editor_get_highlight_guide (GtkEditor* self) {
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = (gint) scintilla_send_message (self->priv->sci, (unsigned int) SCI_GETHIGHLIGHTGUIDE, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
	return result;
}


void gtk_editor_set_highlight_guide (GtkEditor* self, gint value) {
	g_return_if_fail (self != NULL);
	scintilla_send_message (self->priv->sci, (unsigned int) SCI_SETHIGHLIGHTGUIDE, (uptr_t) ((gulong) value), (sptr_t) ((glong) 0));
	g_object_notify ((GObject *) self, "highlight-guide");
}


static void gtk_editor_real_style_needed (GtkEditor* self, gint position) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_char_added (GtkEditor* self, gint ch) {
	g_return_if_fail (self != NULL);
	gtk_editor_update_line_nums (self);
}


static void gtk_editor_real_save_point_reached (GtkEditor* self) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_save_point_left (GtkEditor* self) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_modify_attempt_ro (GtkEditor* self) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_key (GtkEditor* self, gint ch, gint modifiers) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_double_click (GtkEditor* self) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_update_ui (GtkEditor* self) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_modified (GtkEditor* self, gint position, gint modificationType, const char* text, gint length, gint linesAdded, gint line, gint foldLevelNow, gint foldLevelPrev) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_macro_record (GtkEditor* self, gint message, gint wParam, gint lParam) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_margin_click (GtkEditor* self, gint modifiers, gint position, gint margin) {
	g_return_if_fail (self != NULL);
	gtk_editor_margin_click_handler (self, modifiers, position, margin);
}


static void gtk_editor_real_need_shown (GtkEditor* self, gint position, gint length) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_painted (GtkEditor* self) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_user_list_selection (GtkEditor* self, gint listType, const char* text) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
}


static void gtk_editor_real_uri_dropped (GtkEditor* self, const char* text) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
}


static void gtk_editor_real_dwell_start (GtkEditor* self, gint position) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_dwell_end (GtkEditor* self, gint position) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_zoom (GtkEditor* self) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_hot_spot_click (GtkEditor* self, gint modifiers, gint position) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_hot_spot_double_click (GtkEditor* self, gint modifiers, gint position) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_call_tip_click (GtkEditor* self, gint position) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_auto_c_selection (GtkEditor* self, const char* text) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
}


static void gtk_editor_real_indicator_click (GtkEditor* self, gint modifiers, gint position) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_indicator_release (GtkEditor* self, gint modifiers, gint position) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_auto_c_cancelled (GtkEditor* self) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_real_auto_c_char_deleted (GtkEditor* self) {
	g_return_if_fail (self != NULL);
}


static void gtk_editor_class_init (GtkEditorClass * klass) {
	gtk_editor_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GtkEditorPrivate));
	GTK_EDITOR_CLASS (klass)->style_needed = gtk_editor_real_style_needed;
	GTK_EDITOR_CLASS (klass)->char_added = gtk_editor_real_char_added;
	GTK_EDITOR_CLASS (klass)->save_point_reached = gtk_editor_real_save_point_reached;
	GTK_EDITOR_CLASS (klass)->save_point_left = gtk_editor_real_save_point_left;
	GTK_EDITOR_CLASS (klass)->modify_attempt_ro = gtk_editor_real_modify_attempt_ro;
	GTK_EDITOR_CLASS (klass)->key = gtk_editor_real_key;
	GTK_EDITOR_CLASS (klass)->double_click = gtk_editor_real_double_click;
	GTK_EDITOR_CLASS (klass)->update_ui = gtk_editor_real_update_ui;
	GTK_EDITOR_CLASS (klass)->modified = gtk_editor_real_modified;
	GTK_EDITOR_CLASS (klass)->macro_record = gtk_editor_real_macro_record;
	GTK_EDITOR_CLASS (klass)->margin_click = gtk_editor_real_margin_click;
	GTK_EDITOR_CLASS (klass)->need_shown = gtk_editor_real_need_shown;
	GTK_EDITOR_CLASS (klass)->painted = gtk_editor_real_painted;
	GTK_EDITOR_CLASS (klass)->user_list_selection = gtk_editor_real_user_list_selection;
	GTK_EDITOR_CLASS (klass)->uri_dropped = gtk_editor_real_uri_dropped;
	GTK_EDITOR_CLASS (klass)->dwell_start = gtk_editor_real_dwell_start;
	GTK_EDITOR_CLASS (klass)->dwell_end = gtk_editor_real_dwell_end;
	GTK_EDITOR_CLASS (klass)->zoom = gtk_editor_real_zoom;
	GTK_EDITOR_CLASS (klass)->hot_spot_click = gtk_editor_real_hot_spot_click;
	GTK_EDITOR_CLASS (klass)->hot_spot_double_click = gtk_editor_real_hot_spot_double_click;
	GTK_EDITOR_CLASS (klass)->call_tip_click = gtk_editor_real_call_tip_click;
	GTK_EDITOR_CLASS (klass)->auto_c_selection = gtk_editor_real_auto_c_selection;
	GTK_EDITOR_CLASS (klass)->indicator_click = gtk_editor_real_indicator_click;
	GTK_EDITOR_CLASS (klass)->indicator_release = gtk_editor_real_indicator_release;
	GTK_EDITOR_CLASS (klass)->auto_c_cancelled = gtk_editor_real_auto_c_cancelled;
	GTK_EDITOR_CLASS (klass)->auto_c_char_deleted = gtk_editor_real_auto_c_char_deleted;
	G_OBJECT_CLASS (klass)->get_property = gtk_editor_get_property;
	G_OBJECT_CLASS (klass)->set_property = gtk_editor_set_property;
	G_OBJECT_CLASS (klass)->finalize = gtk_editor_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_LEXER, g_param_spec_object ("lexer", "lexer", "lexer", GTK_TYPE_IEDITOR_LEXER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_FOLDING, g_param_spec_boolean ("folding", "folding", "folding", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_FOLD_MARGIN_COLOR, g_param_spec_int ("fold-margin-color", "fold-margin-color", "fold-margin-color", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_FOLD_MARKER_FORE_COLOR, g_param_spec_int ("fold-marker-fore-color", "fold-marker-fore-color", "fold-marker-fore-color", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_FOLD_MARKER_BACK_COLOR, g_param_spec_int ("fold-marker-back-color", "fold-marker-back-color", "fold-marker-back-color", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_FOLD_MARKER_STYLE, g_param_spec_enum ("fold-marker-style", "fold-marker-style", "fold-marker-style", GTK_EDITOR_TYPE_FOLD_MARKER_STYLES, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * Gtk.Editor:default_font_desc:
	 * 
	 * Gets the default Pango font description for the editor, 
	 * which is taken from the system default size and using the
	 * font "Monospace".
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_DEFAULT_FONT_DESC, g_param_spec_string ("default-font-desc", "default-font-desc", "default-font-desc", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	 * Gtk.Editor:font_size:
	 * 
	 * Gets or sets the font size.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_FONT_SIZE, g_param_spec_int ("font-size", "font-size", "font-size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * Gtk.Editor:font_desc:
	 * 
	 * Gets and sets the Pango font description string used to set
	 * the font in the editor.  This sets the font for all styles.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_FONT_DESC, g_param_spec_string ("font-desc", "font-desc", "font-desc", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * Gtk.Editor:line_nums_visible:
	 * 
	 * Gets or sets the visibility of the line numbers margin.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_LINE_NUMS_VISIBLE, g_param_spec_boolean ("line-nums-visible", "line-nums-visible", "line-nums-visible", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_TEXT, g_param_spec_string ("text", "text", "text", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * Gtk.Editor:tab-width:
	 * 
	 * The number of characters that are used to display a tab
	 * character.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_TAB_WIDTH, g_param_spec_int ("tab-width", "tab-width", "tab-width", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * Gtk.Editor:use-tabs:
	 * 
	 * Use tab characters instead of of spaces for indentation.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_USE_TABS, g_param_spec_boolean ("use-tabs", "use-tabs", "use-tabs", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * Gtk.Editor:tab-indents:
	 * 
	 * Whether tab inserts indentation rather than a tab character.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_TAB_INDENTS, g_param_spec_boolean ("tab-indents", "tab-indents", "tab-indents", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * Gtk.Editor:backspace-unindents:
	 * 
	 * Whether backspace removes indents rather than a delete character.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_BACKSPACE_UNINDENTS, g_param_spec_boolean ("backspace-unindents", "backspace-unindents", "backspace-unindents", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * Gtk.Editor:indentation_guides:
	 * 
	 * Gets or sets the view of the indentation guides which is
	 * one of the #IndentViews.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_INDENTATION_GUIDES, g_param_spec_enum ("indentation-guides", "indentation-guides", "indentation-guides", GTK_EDITOR_TYPE_INDENT_VIEWS, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * Gtk.Editor:highlight_guide:
	 * 
	 * Gets or sets the indentation guide to be highlighted with
	 * the brace highlighting style.  Set to 0 to cancel this
	 * highlight.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_EDITOR_HIGHLIGHT_GUIDE, g_param_spec_int ("highlight-guide", "highlight-guide", "highlight-guide", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("style_needed", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, style_needed), NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	g_signal_new ("char_added", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, char_added), NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	g_signal_new ("save_point_reached", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, save_point_reached), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("save_point_left", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, save_point_left), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("modify_attempt_ro", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, modify_attempt_ro), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("key", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, key), NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_INT);
	g_signal_new ("double_click", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, double_click), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("update_ui", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, update_ui), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("modified", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, modified), NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT_STRING_INT_INT_INT_INT_INT, G_TYPE_NONE, 8, G_TYPE_INT, G_TYPE_INT, G_TYPE_STRING, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT);
	g_signal_new ("macro_record", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, macro_record), NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT_INT, G_TYPE_NONE, 3, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT);
	g_signal_new ("margin_click", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, margin_click), NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT_INT, G_TYPE_NONE, 3, G_TYPE_INT, G_TYPE_INT, G_TYPE_INT);
	g_signal_new ("need_shown", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, need_shown), NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_INT);
	g_signal_new ("painted", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, painted), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("user_list_selection", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, user_list_selection), NULL, NULL, g_cclosure_user_marshal_VOID__INT_STRING, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_STRING);
	g_signal_new ("uri_dropped", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, uri_dropped), NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("dwell_start", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, dwell_start), NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	g_signal_new ("dwell_end", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, dwell_end), NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	g_signal_new ("zoom", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, zoom), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("hot_spot_click", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, hot_spot_click), NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_INT);
	g_signal_new ("hot_spot_double_click", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, hot_spot_double_click), NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_INT);
	g_signal_new ("call_tip_click", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, call_tip_click), NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	g_signal_new ("auto_c_selection", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, auto_c_selection), NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("indicator_click", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, indicator_click), NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_INT);
	g_signal_new ("indicator_release", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, indicator_release), NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_INT);
	g_signal_new ("auto_c_cancelled", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, auto_c_cancelled), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("auto_c_char_deleted", GTK_TYPE_EDITOR, G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GtkEditorClass, auto_c_char_deleted), NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void gtk_editor_instance_init (GtkEditor * self) {
	self->priv = GTK_EDITOR_GET_PRIVATE (self);
}


static void gtk_editor_finalize (GObject* obj) {
	GtkEditor * self;
	self = GTK_EDITOR (obj);
	_g_object_unref0 (self->priv->sci);
	_g_free0 (self->priv->_default_font_desc);
	_g_free0 (self->priv->_font_desc);
	_g_free0 (self->priv->_text);
	G_OBJECT_CLASS (gtk_editor_parent_class)->finalize (obj);
}


GType gtk_editor_get_type (void) {
	static volatile gsize gtk_editor_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_editor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GtkEditorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gtk_editor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GtkEditor), 0, (GInstanceInitFunc) gtk_editor_instance_init, NULL };
		GType gtk_editor_type_id;
		gtk_editor_type_id = g_type_register_static (GTK_TYPE_FRAME, "GtkEditor", &g_define_type_info, 0);
		g_once_init_leave (&gtk_editor_type_id__volatile, gtk_editor_type_id);
	}
	return gtk_editor_type_id__volatile;
}


static void gtk_editor_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GtkEditor * self;
	self = GTK_EDITOR (object);
	switch (property_id) {
		case GTK_EDITOR_LEXER:
		g_value_set_object (value, gtk_editor_get_lexer (self));
		break;
		case GTK_EDITOR_FOLDING:
		g_value_set_boolean (value, gtk_editor_get_folding (self));
		break;
		case GTK_EDITOR_FOLD_MARGIN_COLOR:
		g_value_set_int (value, gtk_editor_get_fold_margin_color (self));
		break;
		case GTK_EDITOR_FOLD_MARKER_FORE_COLOR:
		g_value_set_int (value, gtk_editor_get_fold_marker_fore_color (self));
		break;
		case GTK_EDITOR_FOLD_MARKER_BACK_COLOR:
		g_value_set_int (value, gtk_editor_get_fold_marker_back_color (self));
		break;
		case GTK_EDITOR_FOLD_MARKER_STYLE:
		g_value_set_enum (value, gtk_editor_get_fold_marker_style (self));
		break;
		case GTK_EDITOR_DEFAULT_FONT_DESC:
		g_value_set_string (value, gtk_editor_get_default_font_desc (self));
		break;
		case GTK_EDITOR_FONT_SIZE:
		g_value_set_int (value, gtk_editor_get_font_size (self));
		break;
		case GTK_EDITOR_FONT_DESC:
		g_value_set_string (value, gtk_editor_get_font_desc (self));
		break;
		case GTK_EDITOR_LINE_NUMS_VISIBLE:
		g_value_set_boolean (value, gtk_editor_get_line_nums_visible (self));
		break;
		case GTK_EDITOR_TEXT:
		g_value_set_string (value, gtk_editor_get_text (self));
		break;
		case GTK_EDITOR_TAB_WIDTH:
		g_value_set_int (value, gtk_editor_get_tab_width (self));
		break;
		case GTK_EDITOR_USE_TABS:
		g_value_set_boolean (value, gtk_editor_get_use_tabs (self));
		break;
		case GTK_EDITOR_TAB_INDENTS:
		g_value_set_boolean (value, gtk_editor_get_tab_indents (self));
		break;
		case GTK_EDITOR_BACKSPACE_UNINDENTS:
		g_value_set_boolean (value, gtk_editor_get_backspace_unindents (self));
		break;
		case GTK_EDITOR_INDENTATION_GUIDES:
		g_value_set_enum (value, gtk_editor_get_indentation_guides (self));
		break;
		case GTK_EDITOR_HIGHLIGHT_GUIDE:
		g_value_set_int (value, gtk_editor_get_highlight_guide (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void gtk_editor_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GtkEditor * self;
	self = GTK_EDITOR (object);
	switch (property_id) {
		case GTK_EDITOR_LEXER:
		gtk_editor_set_lexer (self, g_value_get_object (value));
		break;
		case GTK_EDITOR_FOLDING:
		gtk_editor_set_folding (self, g_value_get_boolean (value));
		break;
		case GTK_EDITOR_FOLD_MARGIN_COLOR:
		gtk_editor_set_fold_margin_color (self, g_value_get_int (value));
		break;
		case GTK_EDITOR_FOLD_MARKER_FORE_COLOR:
		gtk_editor_set_fold_marker_fore_color (self, g_value_get_int (value));
		break;
		case GTK_EDITOR_FOLD_MARKER_BACK_COLOR:
		gtk_editor_set_fold_marker_back_color (self, g_value_get_int (value));
		break;
		case GTK_EDITOR_FOLD_MARKER_STYLE:
		gtk_editor_set_fold_marker_style (self, g_value_get_enum (value));
		break;
		case GTK_EDITOR_FONT_SIZE:
		gtk_editor_set_font_size (self, g_value_get_int (value));
		break;
		case GTK_EDITOR_FONT_DESC:
		gtk_editor_set_font_desc (self, g_value_get_string (value));
		break;
		case GTK_EDITOR_LINE_NUMS_VISIBLE:
		gtk_editor_set_line_nums_visible (self, g_value_get_boolean (value));
		break;
		case GTK_EDITOR_TEXT:
		gtk_editor_set_text (self, g_value_get_string (value));
		break;
		case GTK_EDITOR_TAB_WIDTH:
		gtk_editor_set_tab_width (self, g_value_get_int (value));
		break;
		case GTK_EDITOR_USE_TABS:
		gtk_editor_set_use_tabs (self, g_value_get_boolean (value));
		break;
		case GTK_EDITOR_TAB_INDENTS:
		gtk_editor_set_tab_indents (self, g_value_get_boolean (value));
		break;
		case GTK_EDITOR_BACKSPACE_UNINDENTS:
		gtk_editor_set_backspace_unindents (self, g_value_get_boolean (value));
		break;
		case GTK_EDITOR_INDENTATION_GUIDES:
		gtk_editor_set_indentation_guides (self, g_value_get_enum (value));
		break;
		case GTK_EDITOR_HIGHLIGHT_GUIDE:
		gtk_editor_set_highlight_guide (self, g_value_get_int (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



static void g_cclosure_user_marshal_VOID__INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__INT_INT) (gpointer data1, gint arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__INT_INT callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int (param_values + 1), g_value_get_int (param_values + 2), data2);
}


static void g_cclosure_user_marshal_VOID__INT_INT_STRING_INT_INT_INT_INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__INT_INT_STRING_INT_INT_INT_INT_INT) (gpointer data1, gint arg_1, gint arg_2, const char* arg_3, gint arg_4, gint arg_5, gint arg_6, gint arg_7, gint arg_8, gpointer data2);
	register GMarshalFunc_VOID__INT_INT_STRING_INT_INT_INT_INT_INT callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 9);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT_INT_STRING_INT_INT_INT_INT_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int (param_values + 1), g_value_get_int (param_values + 2), g_value_get_string (param_values + 3), g_value_get_int (param_values + 4), g_value_get_int (param_values + 5), g_value_get_int (param_values + 6), g_value_get_int (param_values + 7), g_value_get_int (param_values + 8), data2);
}


static void g_cclosure_user_marshal_VOID__INT_INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__INT_INT_INT) (gpointer data1, gint arg_1, gint arg_2, gint arg_3, gpointer data2);
	register GMarshalFunc_VOID__INT_INT_INT callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT_INT_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int (param_values + 1), g_value_get_int (param_values + 2), g_value_get_int (param_values + 3), data2);
}


static void g_cclosure_user_marshal_VOID__INT_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__INT_STRING) (gpointer data1, gint arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__INT_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int (param_values + 1), g_value_get_string (param_values + 2), data2);
}



