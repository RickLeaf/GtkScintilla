/* perl.c generated by valac 0.10.0, the Vala compiler
 * generated from perl.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "gtkeditor.h"
#include <stdlib.h>
#include <string.h>
#include <Scintilla.h>
#include <SciLexer.h>
#include <ScintillaWidget.h>
#include <glib/gstdio.h>
#include <stdio.h>

#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))


static gpointer gtk_perl_lexer_parent_class = NULL;
static GtkIEditorLexerIface* gtk_perl_lexer_gtk_ieditor_lexer_parent_iface = NULL;

enum  {
	GTK_PERL_LEXER_DUMMY_PROPERTY
};
static gboolean gtk_perl_lexer_real_write_config (GtkIEditorLexer* base, const char* filename);
static gboolean gtk_perl_lexer_real_read_config (GtkIEditorLexer* base, const char* filename);
static char** gtk_perl_lexer_real_list_props (GtkIEditorLexer* base, int* result_length1);
static void _vala_array_add2 (char*** array, int* length, int* size, char* value);
static gboolean gtk_perl_lexer_real_has_prop (GtkIEditorLexer* base, const char* propname);
static gboolean gtk_perl_lexer_real_get_prop_as_int (GtkIEditorLexer* base, const char* propname, gint* propvalue);
static gboolean gtk_perl_lexer_real_get_prop_as_bool (GtkIEditorLexer* base, const char* propname, gboolean* propvalue);
static gboolean gtk_perl_lexer_real_get_prop_as_string (GtkIEditorLexer* base, const char* propname, char** propvalue);
static int gtk_perl_lexer_real_get_prop_type (GtkIEditorLexer* base, const char* propname);
static char* gtk_perl_lexer_real_get_prop (GtkIEditorLexer* base, const char* propname);
static gboolean gtk_perl_lexer_real_set_prop (GtkIEditorLexer* base, const char* propname, const char* propvalue);
static void gtk_perl_lexer_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static int _vala_strcmp0 (const char * str1, const char * str2);



GtkPerlLexer* gtk_perl_lexer_construct (GType object_type, ScintillaObject* sci) {
	GtkPerlLexer * self;
	self = (GtkPerlLexer*) g_object_new (object_type, NULL);
	self->sci = sci;
	scintilla_send_message (self->sci, (unsigned int) SCI_SETLEXER, (uptr_t) ((gulong) GTK_PERL_LEXER_lexer_index), (sptr_t) ((glong) 0));
	return self;
}


GtkPerlLexer* gtk_perl_lexer_new (ScintillaObject* sci) {
	return gtk_perl_lexer_construct (GTK_TYPE_PERL_LEXER, sci);
}


static gboolean gtk_perl_lexer_real_write_config (GtkIEditorLexer* base, const char* filename) {
	GtkPerlLexer * self;
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	self = (GtkPerlLexer*) base;
	g_return_val_if_fail (filename != NULL, FALSE);
	{
		GKeyFile* kf;
		char* data;
		kf = g_key_file_new ();
		g_key_file_set_integer (kf, "LEXER", "LEXER_ID", GTK_PERL_LEXER_lexer_index);
		g_key_file_set_comment (kf, "LEXER", "LEXER_ID", "Do not change LEXER_ID or LEXER_NAME", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch3_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch3_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		g_key_file_set_string (kf, "LEXER", "LEXER_NAME", GTK_PERL_LEXER_lexer_name);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp0_;
				_tmp0_ = TRUE;
				while (TRUE) {
					char* config_prop_name;
					char* lexer_prop_name;
					char* lexer_prop_type;
					char* comment;
					const char* _tmp3_;
					GQuark _tmp4_;
					static GQuark _tmp4__label0 = 0;
					static GQuark _tmp4__label1 = 0;
					if (!_tmp0_) {
						i++;
					}
					_tmp0_ = FALSE;
					if (!(i < self->lexer_properties_length1)) {
						break;
					}
					config_prop_name = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 0]);
					lexer_prop_name = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 1]);
					lexer_prop_type = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 2]);
					comment = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 3]);
					_tmp3_ = lexer_prop_type;
					_tmp4_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
					if (_tmp4_ == ((0 != _tmp4__label0) ? _tmp4__label0 : (_tmp4__label0 = g_quark_from_static_string ("bool"))))
					switch (0) {
						default:
						{
							gboolean prop_val = FALSE;
							gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, lexer_prop_name, &prop_val);
							g_key_file_set_boolean (kf, "LEXER", config_prop_name, prop_val);
							break;
						}
					} else if (_tmp4_ == ((0 != _tmp4__label1) ? _tmp4__label1 : (_tmp4__label1 = g_quark_from_static_string ("int"))))
					switch (0) {
						default:
						{
							gint prop_val = 0;
							gtk_ieditor_lexer_get_prop_as_int ((GtkIEditorLexer*) self, lexer_prop_name, &prop_val);
							g_key_file_set_integer (kf, "LEXER", config_prop_name, prop_val);
							break;
						}
					} else
					switch (0) {
						default:
						{
							char* prop_val;
							char* _tmp1_ = NULL;
							char* _tmp2_;
							prop_val = NULL;
							gtk_ieditor_lexer_get_prop_as_string ((GtkIEditorLexer*) self, lexer_prop_name, &_tmp1_);
							prop_val = (_tmp2_ = _tmp1_, _g_free0 (prop_val), _tmp2_);
							g_key_file_set_string (kf, "LEXER", config_prop_name, prop_val);
							_g_free0 (prop_val);
							break;
						}
					}
					g_key_file_set_comment (kf, "LEXER", config_prop_name, comment, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (comment);
						_g_free0 (lexer_prop_type);
						_g_free0 (lexer_prop_name);
						_g_free0 (config_prop_name);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch3_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch3_g_file_error;
						}
						_g_free0 (comment);
						_g_free0 (lexer_prop_type);
						_g_free0 (lexer_prop_name);
						_g_free0 (config_prop_name);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					_g_free0 (comment);
					_g_free0 (lexer_prop_type);
					_g_free0 (lexer_prop_name);
					_g_free0 (config_prop_name);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp5_;
				_tmp5_ = TRUE;
				while (TRUE) {
					char* comment;
					char* keywords;
					char* keyname;
					if (!_tmp5_) {
						i++;
					}
					_tmp5_ = FALSE;
					if (!(i < self->lexer_keywords_length1)) {
						break;
					}
					comment = g_strdup (self->lexer_keywords[(i * self->lexer_keywords_length2) + 0]);
					keywords = g_strdup (self->lexer_keywords[(i * self->lexer_keywords_length2) + 1]);
					keyname = g_strdup_printf ("KEYWORDS_%d", i);
					g_key_file_set_string (kf, "KEYWORDS", keyname, keywords);
					g_key_file_set_comment (kf, "KEYWORDS", keyname, comment, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (keyname);
						_g_free0 (keywords);
						_g_free0 (comment);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch3_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch3_g_file_error;
						}
						_g_free0 (keyname);
						_g_free0 (keywords);
						_g_free0 (comment);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					_g_free0 (keyname);
					_g_free0 (keywords);
					_g_free0 (comment);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp6_;
				_tmp6_ = TRUE;
				while (TRUE) {
					char* name;
					gint index;
					char* keyname;
					char* comment;
					gint fg_color;
					gint bg_color;
					gboolean bold;
					gboolean italic;
					const char* _tmp7_;
					const char* _tmp8_;
					char* valstr;
					if (!_tmp6_) {
						i++;
					}
					_tmp6_ = FALSE;
					if (!(i < self->lexer_styles_length1)) {
						break;
					}
					name = g_strdup (self->lexer_styles[(i * self->lexer_styles_length2) + 0]);
					index = atoi (self->lexer_styles[(i * self->lexer_styles_length2) + 1]);
					keyname = g_strdup_printf ("STYLE_%d", index);
					comment = g_strdup (self->lexer_styles[(i * self->lexer_styles_length2) + 2]);
					fg_color = (gint) scintilla_send_message (self->sci, (unsigned int) SCI_STYLEGETFORE, (uptr_t) ((gulong) index), (sptr_t) ((glong) 0));
					bg_color = (gint) scintilla_send_message (self->sci, (unsigned int) SCI_STYLEGETBACK, (uptr_t) ((gulong) index), (sptr_t) ((glong) 0));
					bold = (gboolean) scintilla_send_message (self->sci, (unsigned int) SCI_STYLEGETBOLD, (uptr_t) ((gulong) index), (sptr_t) ((glong) 0));
					italic = (gboolean) scintilla_send_message (self->sci, (unsigned int) SCI_STYLEGETITALIC, (uptr_t) ((gulong) index), (sptr_t) ((glong) 0));
					_tmp7_ = NULL;
					if (bold) {
						_tmp7_ = "true";
					} else {
						_tmp7_ = "false";
					}
					_tmp8_ = NULL;
					if (italic) {
						_tmp8_ = "true";
					} else {
						_tmp8_ = "false";
					}
					valstr = g_strdup_printf ("0x%06x;0x%06x;%s;%s;", (guint) fg_color, (guint) bg_color, _tmp7_, _tmp8_);
					g_key_file_set_string (kf, "STYLES", keyname, valstr);
					g_key_file_set_comment (kf, "STYLES", keyname, comment, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (valstr);
						_g_free0 (comment);
						_g_free0 (keyname);
						_g_free0 (name);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch3_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch3_g_file_error;
						}
						_g_free0 (valstr);
						_g_free0 (comment);
						_g_free0 (keyname);
						_g_free0 (name);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					_g_free0 (valstr);
					_g_free0 (comment);
					_g_free0 (keyname);
					_g_free0 (name);
				}
			}
		}
		data = g_key_file_to_data (kf, NULL, NULL);
		g_file_set_contents (filename, data, -1, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (data);
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch3_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch3_g_file_error;
			}
			_g_free0 (data);
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_g_free0 (data);
		_g_key_file_free0 (kf);
	}
	goto __finally3;
	__catch3_g_key_file_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("perl.vala:174: %s", err->message);
			result = FALSE;
			_g_error_free0 (err);
			return result;
		}
	}
	goto __finally3;
	__catch3_g_file_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("perl.vala:178: %s", err->message);
			result = FALSE;
			_g_error_free0 (err);
			return result;
		}
	}
	__finally3:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static gboolean string_to_bool (const char* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (_vala_strcmp0 (self, "true") == 0) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


static gboolean gtk_perl_lexer_real_read_config (GtkIEditorLexer* base, const char* filename) {
	GtkPerlLexer * self;
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	self = (GtkPerlLexer*) base;
	g_return_val_if_fail (filename != NULL, FALSE);
	{
		GKeyFile* kf;
		gboolean _tmp0_;
		gint lexid;
		char* _tmp1_;
		char* _tmp2_;
		char* _tmp3_;
		char* lexname;
		kf = g_key_file_new ();
		g_key_file_load_from_file (kf, filename, G_KEY_FILE_NONE, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch4_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch4_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		if (!g_key_file_has_group (kf, "LEXER")) {
			fprintf (stdout, "Lexer section not found in config file\n");
			result = FALSE;
			_g_key_file_free0 (kf);
			return result;
		}
		_tmp0_ = g_key_file_has_key (kf, "LEXER", "LEXER_ID", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch4_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch4_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		if (!_tmp0_) {
			fprintf (stdout, "Lexer ID key not found in config file\n");
			result = FALSE;
			_g_key_file_free0 (kf);
			return result;
		}
		lexid = g_key_file_get_integer (kf, "LEXER", "LEXER_ID", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch4_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch4_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		if (lexid != GTK_PERL_LEXER_lexer_index) {
			fprintf (stdout, "Wrong config file for this lexer ID\n");
			result = FALSE;
			_g_key_file_free0 (kf);
			return result;
		}
		_tmp1_ = g_key_file_get_string (kf, "LEXER", "LEXER_NAME", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch4_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch4_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		lexname = (_tmp3_ = string_strip (_tmp2_ = _tmp1_), _g_free0 (_tmp2_), _tmp3_);
		if (_vala_strcmp0 (lexname, GTK_PERL_LEXER_lexer_name) != 0) {
			fprintf (stdout, "Wrong config file for this lexer name\n");
			result = FALSE;
			_g_free0 (lexname);
			_g_key_file_free0 (kf);
			return result;
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					char* config_prop_name;
					char* lexer_prop_name;
					char* lexer_prop_type;
					char* comment;
					const char* _tmp9_;
					GQuark _tmp10_;
					static GQuark _tmp10__label0 = 0;
					static GQuark _tmp10__label1 = 0;
					if (!_tmp4_) {
						i++;
					}
					_tmp4_ = FALSE;
					if (!(i < self->lexer_properties_length1)) {
						break;
					}
					config_prop_name = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 0]);
					lexer_prop_name = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 1]);
					lexer_prop_type = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 2]);
					comment = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 3]);
					_tmp9_ = lexer_prop_type;
					_tmp10_ = (NULL == _tmp9_) ? 0 : g_quark_from_string (_tmp9_);
					if (_tmp10_ == ((0 != _tmp10__label0) ? _tmp10__label0 : (_tmp10__label0 = g_quark_from_static_string ("bool"))))
					switch (0) {
						default:
						{
							gboolean _tmp5_;
							_tmp5_ = g_key_file_has_key (kf, "LEXER", config_prop_name, &_inner_error_);
							if (_inner_error_ != NULL) {
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								if (_inner_error_->domain == G_KEY_FILE_ERROR) {
									goto __catch4_g_key_file_error;
								}
								if (_inner_error_->domain == G_FILE_ERROR) {
									goto __catch4_g_file_error;
								}
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
							if (_tmp5_) {
								gboolean val;
								const char* _tmp6_;
								char* prop_val;
								val = g_key_file_get_boolean (kf, "LEXER", config_prop_name, &_inner_error_);
								if (_inner_error_ != NULL) {
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										goto __catch4_g_key_file_error;
									}
									if (_inner_error_->domain == G_FILE_ERROR) {
										goto __catch4_g_file_error;
									}
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
								_tmp6_ = NULL;
								if (val) {
									_tmp6_ = "1";
								} else {
									_tmp6_ = "0";
								}
								prop_val = g_strdup (_tmp6_);
								gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, lexer_prop_name, prop_val);
								_g_free0 (prop_val);
							}
							break;
						}
					} else if (_tmp10_ == ((0 != _tmp10__label1) ? _tmp10__label1 : (_tmp10__label1 = g_quark_from_static_string ("int"))))
					switch (0) {
						default:
						{
							gboolean _tmp7_;
							_tmp7_ = g_key_file_has_key (kf, "LEXER", config_prop_name, &_inner_error_);
							if (_inner_error_ != NULL) {
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								if (_inner_error_->domain == G_KEY_FILE_ERROR) {
									goto __catch4_g_key_file_error;
								}
								if (_inner_error_->domain == G_FILE_ERROR) {
									goto __catch4_g_file_error;
								}
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
							if (_tmp7_) {
								gint val;
								char* prop_val;
								val = g_key_file_get_integer (kf, "LEXER", config_prop_name, &_inner_error_);
								if (_inner_error_ != NULL) {
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										goto __catch4_g_key_file_error;
									}
									if (_inner_error_->domain == G_FILE_ERROR) {
										goto __catch4_g_file_error;
									}
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
								prop_val = g_strdup_printf ("%i", val);
								gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, lexer_prop_name, prop_val);
								_g_free0 (prop_val);
							}
							break;
						}
					} else
					switch (0) {
						default:
						{
							gboolean _tmp8_;
							_tmp8_ = g_key_file_has_key (kf, "LEXER", config_prop_name, &_inner_error_);
							if (_inner_error_ != NULL) {
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								if (_inner_error_->domain == G_KEY_FILE_ERROR) {
									goto __catch4_g_key_file_error;
								}
								if (_inner_error_->domain == G_FILE_ERROR) {
									goto __catch4_g_file_error;
								}
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
							if (_tmp8_) {
								char* prop_val;
								prop_val = g_key_file_get_string (kf, "LEXER", config_prop_name, &_inner_error_);
								if (_inner_error_ != NULL) {
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										goto __catch4_g_key_file_error;
									}
									if (_inner_error_->domain == G_FILE_ERROR) {
										goto __catch4_g_file_error;
									}
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
								gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, lexer_prop_name, prop_val);
								_g_free0 (prop_val);
							}
							break;
						}
					}
					_g_free0 (comment);
					_g_free0 (lexer_prop_type);
					_g_free0 (lexer_prop_name);
					_g_free0 (config_prop_name);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp11_;
				_tmp11_ = TRUE;
				while (TRUE) {
					char* keyname;
					gboolean _tmp12_;
					if (!_tmp11_) {
						i++;
					}
					_tmp11_ = FALSE;
					if (!(i < self->lexer_keywords_length1)) {
						break;
					}
					keyname = g_strdup_printf ("KEYWORDS_%d", i);
					_tmp12_ = g_key_file_has_key (kf, "KEYWORDS", keyname, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (keyname);
						_g_free0 (lexname);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch4_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch4_g_file_error;
						}
						_g_free0 (keyname);
						_g_free0 (lexname);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					if (_tmp12_) {
						char* _tmp13_;
						char* *_tmp14_;
						char* _tmp15_;
						_tmp13_ = g_key_file_get_string (kf, "KEYWORDS", keyname, &_inner_error_);
						if (_inner_error_ != NULL) {
							_g_free0 (keyname);
							_g_free0 (lexname);
							_g_key_file_free0 (kf);
							if (_inner_error_->domain == G_KEY_FILE_ERROR) {
								goto __catch4_g_key_file_error;
							}
							if (_inner_error_->domain == G_FILE_ERROR) {
								goto __catch4_g_file_error;
							}
							_g_free0 (keyname);
							_g_free0 (lexname);
							_g_key_file_free0 (kf);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
						_tmp14_ = &self->lexer_keywords[(i * self->lexer_keywords_length2) + 1];
						(*_tmp14_) = (_tmp15_ = _tmp13_, _g_free0 ((*_tmp14_)), _tmp15_);
						scintilla_send_message (self->sci, (unsigned int) SCI_SETKEYWORDS, (uptr_t) ((gulong) i), (sptr_t) ((glong) self->lexer_keywords[(i * self->lexer_keywords_length2) + 1]));
					}
					_g_free0 (keyname);
				}
			}
		}
		scintilla_send_message (self->sci, (unsigned int) SCI_STYLECLEARALL, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
		{
			gint i;
			i = 0;
			{
				gboolean _tmp16_;
				_tmp16_ = TRUE;
				while (TRUE) {
					gint index;
					char* keyname;
					gboolean _tmp17_;
					if (!_tmp16_) {
						i++;
					}
					_tmp16_ = FALSE;
					if (!(i < self->lexer_styles_length1)) {
						break;
					}
					index = atoi (self->lexer_styles[(i * self->lexer_styles_length2) + 1]);
					keyname = g_strdup_printf ("STYLE_%d", index);
					_tmp17_ = g_key_file_has_key (kf, "STYLES", keyname, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (keyname);
						_g_free0 (lexname);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch4_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch4_g_file_error;
						}
						_g_free0 (keyname);
						_g_free0 (lexname);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					if (_tmp17_) {
						gint keyvalues_length1;
						gint _keyvalues_size_;
						char** _tmp19_;
						gsize _tmp18_;
						char** keyvalues;
						gint kvlen;
						keyvalues = (_tmp19_ = g_key_file_get_string_list (kf, "STYLES", keyname, &_tmp18_, &_inner_error_), keyvalues_length1 = _tmp18_, _keyvalues_size_ = keyvalues_length1, _tmp19_);
						if (_inner_error_ != NULL) {
							_g_free0 (keyname);
							_g_free0 (lexname);
							_g_key_file_free0 (kf);
							if (_inner_error_->domain == G_KEY_FILE_ERROR) {
								goto __catch4_g_key_file_error;
							}
							if (_inner_error_->domain == G_FILE_ERROR) {
								goto __catch4_g_file_error;
							}
							_g_free0 (keyname);
							_g_free0 (lexname);
							_g_key_file_free0 (kf);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
						kvlen = keyvalues_length1;
						if (kvlen > 0) {
							gint fg_color;
							fg_color = gtk_editor_style_hex_to_dec (keyvalues[0]);
							scintilla_send_message (self->sci, (unsigned int) SCI_STYLESETFORE, (uptr_t) ((gulong) index), (sptr_t) ((glong) fg_color));
						}
						if (kvlen > 1) {
							gint bg_color;
							bg_color = gtk_editor_style_hex_to_dec (keyvalues[1]);
							scintilla_send_message (self->sci, (unsigned int) SCI_STYLESETBACK, (uptr_t) ((gulong) index), (sptr_t) ((glong) bg_color));
						}
						if (kvlen > 2) {
							char* _tmp20_;
							gboolean _tmp21_;
							gboolean bold;
							bold = (_tmp21_ = string_to_bool (_tmp20_ = string_strip (keyvalues[2])), _g_free0 (_tmp20_), _tmp21_);
							scintilla_send_message (self->sci, (unsigned int) SCI_STYLESETBOLD, (uptr_t) ((gulong) index), (sptr_t) ((glong) bold));
						}
						if (kvlen > 3) {
							char* _tmp22_;
							gboolean _tmp23_;
							gboolean italic;
							italic = (_tmp23_ = string_to_bool (_tmp22_ = string_strip (keyvalues[3])), _g_free0 (_tmp22_), _tmp23_);
							scintilla_send_message (self->sci, (unsigned int) SCI_STYLESETITALIC, (uptr_t) ((gulong) index), (sptr_t) ((glong) italic));
						}
						keyvalues = (_vala_array_free (keyvalues, keyvalues_length1, (GDestroyNotify) g_free), NULL);
					}
					_g_free0 (keyname);
				}
			}
		}
		_g_free0 (lexname);
		_g_key_file_free0 (kf);
	}
	goto __finally4;
	__catch4_g_key_file_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("perl.vala:298: %s", err->message);
			_g_error_free0 (err);
		}
	}
	goto __finally4;
	__catch4_g_file_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("perl.vala:301: %s", err->message);
			_g_error_free0 (err);
		}
	}
	__finally4:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


static void _vala_array_add2 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static char** gtk_perl_lexer_real_list_props (GtkIEditorLexer* base, int* result_length1) {
	GtkPerlLexer * self;
	char** result = NULL;
	gint props_length1;
	gint _props_size_;
	char** _tmp1_;
	char** _tmp0_ = NULL;
	char** props;
	char** _tmp3_;
	self = (GtkPerlLexer*) base;
	props = (_tmp1_ = (_tmp0_ = g_new0 (char*, 0 + 1), _tmp0_), props_length1 = 0, _props_size_ = props_length1, _tmp1_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				char* pname;
				gint len;
				if (!_tmp2_) {
					i++;
				}
				_tmp2_ = FALSE;
				if (!(i < self->lexer_properties_length1)) {
					break;
				}
				pname = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 1]);
				len = (gint) scintilla_send_message (self->sci, (unsigned int) SCI_GETPROPERTY, (uptr_t) ((gulong) pname), (sptr_t) ((glong) 0));
				if (len != 0) {
					_vala_array_add2 (&props, &props_length1, &_props_size_, g_strdup (pname));
				}
				_g_free0 (pname);
			}
		}
	}
	result = (_tmp3_ = props, *result_length1 = props_length1, _tmp3_);
	return result;
	props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
}


static gboolean gtk_perl_lexer_real_has_prop (GtkIEditorLexer* base, const char* propname) {
	GtkPerlLexer * self;
	gboolean result = FALSE;
	self = (GtkPerlLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->lexer_properties_length1)) {
					break;
				}
				if (_vala_strcmp0 (self->lexer_properties[(i * self->lexer_properties_length2) + 1], propname) == 0) {
					result = TRUE;
					return result;
				}
			}
		}
	}
	result = FALSE;
	return result;
}


static gboolean gtk_perl_lexer_real_get_prop_as_int (GtkIEditorLexer* base, const char* propname, gint* propvalue) {
	GtkPerlLexer * self;
	gboolean result = FALSE;
	char* strval;
	self = (GtkPerlLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	strval = gtk_ieditor_lexer_get_prop ((GtkIEditorLexer*) self, propname);
	if (strval != NULL) {
		*propvalue = atoi (strval);
		result = TRUE;
		_g_free0 (strval);
		return result;
	}
	result = FALSE;
	_g_free0 (strval);
	return result;
}


static gboolean gtk_perl_lexer_real_get_prop_as_bool (GtkIEditorLexer* base, const char* propname, gboolean* propvalue) {
	GtkPerlLexer * self;
	gboolean result = FALSE;
	char* strval;
	self = (GtkPerlLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	strval = gtk_ieditor_lexer_get_prop ((GtkIEditorLexer*) self, propname);
	if (strval != NULL) {
		*propvalue = (gboolean) atoi (strval);
		result = TRUE;
		_g_free0 (strval);
		return result;
	}
	result = FALSE;
	_g_free0 (strval);
	return result;
}


static gboolean gtk_perl_lexer_real_get_prop_as_string (GtkIEditorLexer* base, const char* propname, char** propvalue) {
	GtkPerlLexer * self;
	gboolean result = FALSE;
	char* strval;
	self = (GtkPerlLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	if (propvalue != NULL) {
		*propvalue = NULL;
	}
	strval = gtk_ieditor_lexer_get_prop ((GtkIEditorLexer*) self, propname);
	if (strval != NULL) {
		char* _tmp0_;
		*propvalue = (_tmp0_ = g_strdup (strval), _g_free0 (*propvalue), _tmp0_);
		result = TRUE;
		_g_free0 (strval);
		return result;
	}
	result = FALSE;
	_g_free0 (strval);
	return result;
}


static int gtk_perl_lexer_real_get_prop_type (GtkIEditorLexer* base, const char* propname) {
	GtkPerlLexer * self;
	int result = 0;
	int prop_type = 0;
	self = (GtkPerlLexer*) base;
	g_return_val_if_fail (propname != NULL, 0);
	prop_type = (int) scintilla_send_message (self->sci, (unsigned int) SCI_PROPERTYTYPE, (uptr_t) ((gulong) propname), (sptr_t) ((glong) 0));
	result = prop_type;
	return result;
}


static char* gtk_perl_lexer_real_get_prop (GtkIEditorLexer* base, const char* propname) {
	GtkPerlLexer * self;
	char* result = NULL;
	gint len;
	gchar* val;
	char* prop_value;
	self = (GtkPerlLexer*) base;
	g_return_val_if_fail (propname != NULL, NULL);
	if (!gtk_ieditor_lexer_has_prop ((GtkIEditorLexer*) self, propname)) {
		result = NULL;
		return result;
	}
	len = (gint) scintilla_send_message (self->sci, (unsigned int) SCI_GETPROPERTY, (uptr_t) ((gulong) propname), (sptr_t) ((glong) 0));
	val = g_malloc0 ((gsize) (len + 1));
	scintilla_send_message (self->sci, (unsigned int) SCI_GETPROPERTY, (uptr_t) ((gulong) propname), (sptr_t) ((glong) val));
	prop_value = g_strdup ((const char*) val);
	g_free (val);
	result = prop_value;
	return result;
}


static gboolean gtk_perl_lexer_real_set_prop (GtkIEditorLexer* base, const char* propname, const char* propvalue) {
	GtkPerlLexer * self;
	gboolean result = FALSE;
	char* _tmp0_;
	gboolean _tmp1_;
	self = (GtkPerlLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	g_return_val_if_fail (propvalue != NULL, FALSE);
	if (!gtk_ieditor_lexer_has_prop ((GtkIEditorLexer*) self, propname)) {
		result = FALSE;
		return result;
	}
	scintilla_send_message (self->sci, (unsigned int) SCI_SETPROPERTY, (uptr_t) ((gulong) propname), (sptr_t) ((glong) propvalue));
	result = (_tmp1_ = _vala_strcmp0 (_tmp0_ = gtk_ieditor_lexer_get_prop ((GtkIEditorLexer*) self, propname), propvalue) == 0, _g_free0 (_tmp0_), _tmp1_);
	return result;
}


static void gtk_perl_lexer_class_init (GtkPerlLexerClass * klass) {
	gtk_perl_lexer_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = gtk_perl_lexer_finalize;
}


static void gtk_perl_lexer_gtk_ieditor_lexer_interface_init (GtkIEditorLexerIface * iface) {
	gtk_perl_lexer_gtk_ieditor_lexer_parent_iface = g_type_interface_peek_parent (iface);
	iface->write_config = gtk_perl_lexer_real_write_config;
	iface->read_config = gtk_perl_lexer_real_read_config;
	iface->list_props = gtk_perl_lexer_real_list_props;
	iface->has_prop = gtk_perl_lexer_real_has_prop;
	iface->get_prop_as_int = gtk_perl_lexer_real_get_prop_as_int;
	iface->get_prop_as_bool = gtk_perl_lexer_real_get_prop_as_bool;
	iface->get_prop_as_string = gtk_perl_lexer_real_get_prop_as_string;
	iface->get_prop_type = gtk_perl_lexer_real_get_prop_type;
	iface->get_prop = gtk_perl_lexer_real_get_prop;
	iface->set_prop = gtk_perl_lexer_real_set_prop;
}


static void gtk_perl_lexer_instance_init (GtkPerlLexer * self) {
	char** _tmp0_ = NULL;
	char** _tmp1_ = NULL;
	char** _tmp2_ = NULL;
	self->lexer_properties = (_tmp0_ = g_new0 (char*, (5 * 4) + 1), _tmp0_[0] = g_strdup ("FOLD_POD_BLOCKS"), _tmp0_[1] = g_strdup ("fold.perl.pod"), _tmp0_[2] = g_strdup ("bool"), _tmp0_[3] = g_strdup ("Enable folding Pod blocks"), _tmp0_[4] = g_strdup ("FOLD_PACKAGES"), _tmp0_[5] = g_strdup ("fold.perl.package"), _tmp0_[6] = g_strdup ("bool"), _tmp0_[7] = g_strdup ("Enable folding packages"), _tmp0_[8] = g_strdup ("FOLD"), _tmp0_[9] = g_strdup ("fold"), _tmp0_[10] = g_strdup ("bool"), _tmp0_[11] = g_strdup ("Enable code folding"), _tmp0_[12] = g_strdup ("FOLD_COMMENTS"), _tmp0_[13] = g_strdup ("fold.comment"), _tmp0_[14] = g_strdup ("bool"), _tmp0_[15] = g_strdup ("This option enables folding multi-line comments"), _tmp0_[16] = g_strdup ("FOLD_COMPACT"), _tmp0_[17] = g_strdup ("fold.compact"), _tmp0_[18] = g_strdup ("bool"), _tmp0_[19] = g_strdup ("Enable folding blank lines when folding."), _tmp0_);
	self->lexer_properties_length1 = 5;
	self->lexer_properties_length2 = 4;
	self->lexer_keywords = (_tmp1_ = g_new0 (char*, (1 * 2) + 1), _tmp1_[0] = g_strdup ("Keywords"), _tmp1_[1] = g_strdup (""), _tmp1_);
	self->lexer_keywords_length1 = 1;
	self->lexer_keywords_length2 = 2;
	self->lexer_styles = (_tmp2_ = g_new0 (char*, (35 * 3) + 1), _tmp2_[0] = g_strdup ("DEFAULT"), _tmp2_[1] = g_strdup ("0"), _tmp2_[2] = g_strdup ("Default style"), _tmp2_[3] = g_strdup ("ERROR"), _tmp2_[4] = g_strdup ("1"), _tmp2_[5] = g_strdup ("Errors"), _tmp2_[6] = g_strdup ("COMMENTLINE"), _tmp2_[7] = g_strdup ("2"), _tmp2_[8] = g_strdup ("Single line comments"), _tmp2_[9] = g_strdup ("POD"), _tmp2_[10] = g_strdup ("3"), _tmp2_[11] = g_strdup ("Plain old documentation blocks"), _tmp2_[12] = g_strdup ("NUMBER"), _tmp2_[13] = g_strdup ("4"), _tmp2_[14] = g_strdup ("Numbers"), _tmp2_[15] = g_strdup ("WORD"), _tmp2_[16] = g_strdup ("5"), _tmp2_[17] = g_strdup ("Keywords (first set of keywords)"), _tmp2_[18] = g_strdup ("STRING"), _tmp2_[19] = g_strdup ("6"), _tmp2_[20] = g_strdup ("String literals"), _tmp2_[21] = g_strdup ("CHARACTER"), _tmp2_[22] = g_strdup ("7"), _tmp2_[23] = g_strdup ("Character literals"), _tmp2_[24] = g_strdup ("PUNCTUATION"), _tmp2_[25] = g_strdup ("8"), _tmp2_[26] = g_strdup ("Punctuation marks"), _tmp2_[27] = g_strdup ("PREPROCESSOR"), _tmp2_[28] = g_strdup ("9"), _tmp2_[29] = g_strdup ("Preprocessor macros"), _tmp2_[30] = g_strdup ("OPERATOR"), _tmp2_[31] = g_strdup ("10"), _tmp2_[32] = g_strdup ("Operators"), _tmp2_[33] = g_strdup ("IDENTIFIER"), _tmp2_[34] = g_strdup ("11"), _tmp2_[35] = g_strdup ("Indentifiers"), _tmp2_[36] = g_strdup ("SCALAR"), _tmp2_[37] = g_strdup ("12"), _tmp2_[38] = g_strdup ("Scalars"), _tmp2_[39] = g_strdup ("ARRAY"), _tmp2_[40] = g_strdup ("13"), _tmp2_[41] = g_strdup ("Arrays"), _tmp2_[42] = g_strdup ("HASH"), _tmp2_[43] = g_strdup ("14"), _tmp2_[44] = g_strdup ("Hashes"), _tmp2_[45] = g_strdup ("SYMBOLTABLE"), _tmp2_[46] = g_strdup ("15"), _tmp2_[47] = g_strdup ("Symbol tables"), _tmp2_[48] = g_strdup ("VARIABLE_INDEXER"), _tmp2_[49] = g_strdup ("16"), _tmp2_[50] = g_strdup ("Variable indexer"), _tmp2_[51] = g_strdup ("REGEX"), _tmp2_[52] = g_strdup ("17"), _tmp2_[53] = g_strdup ("Regular expressions"), _tmp2_[54] = g_strdup ("REGSUBST"), _tmp2_[55] = g_strdup ("18"), _tmp2_[56] = g_strdup ("Regular expression substitutions"), _tmp2_[57] = g_strdup ("LONGQUOTE"), _tmp2_[58] = g_strdup ("19"), _tmp2_[59] = g_strdup ("Long quotes"), _tmp2_[60] = g_strdup ("BACKTICKS"), _tmp2_[61] = g_strdup ("20"), _tmp2_[62] = g_strdup ("Backticks"), _tmp2_[63] = g_strdup ("DATASECTION"), _tmp2_[64] = g_strdup ("21"), _tmp2_[65] = g_strdup ("Data sections"), _tmp2_[66] = g_strdup ("HERE_DELIM"), _tmp2_[67] = g_strdup ("22"), _tmp2_[68] = g_strdup ("Here delimiter"), _tmp2_[69] = g_strdup ("HERE_Q"), _tmp2_[70] = g_strdup ("23"), _tmp2_[71] = g_strdup ("Here Q"), _tmp2_[72] = g_strdup ("HERE_QQ"), _tmp2_[73] = g_strdup ("24"), _tmp2_[74] = g_strdup ("Here QQ"), _tmp2_[75] = g_strdup ("HERE_QX"), _tmp2_[76] = g_strdup ("25"), _tmp2_[77] = g_strdup ("Here QX"), _tmp2_[78] = g_strdup ("STRING_Q"), _tmp2_[79] = g_strdup ("26"), _tmp2_[80] = g_strdup ("String Q"), _tmp2_[81] = g_strdup ("STRING_QQ"), _tmp2_[82] = g_strdup ("27"), _tmp2_[83] = g_strdup ("String QQ"), _tmp2_[84] = g_strdup ("STRING_QX"), _tmp2_[85] = g_strdup ("28"), _tmp2_[86] = g_strdup ("String QX"), _tmp2_[87] = g_strdup ("STRING_QR"), _tmp2_[88] = g_strdup ("29"), _tmp2_[89] = g_strdup ("String QR"), _tmp2_[90] = g_strdup ("STRING_QW"), _tmp2_[91] = g_strdup ("30"), _tmp2_[92] = g_strdup ("String QW"), _tmp2_[93] = g_strdup ("POD_VERB"), _tmp2_[94] = g_strdup ("31"), _tmp2_[95] = g_strdup ("Plain old documentation verbatim"), _tmp2_[96] = g_strdup ("SUB_PROTOTYPE"), _tmp2_[97] = g_strdup ("40"), _tmp2_[98] = g_strdup ("Sub prototype"), _tmp2_[99] = g_strdup ("FORMAT_IDENT"), _tmp2_[100] = g_strdup ("41"), _tmp2_[101] = g_strdup ("Format identifier"), _tmp2_[102] = g_strdup ("FORMAT"), _tmp2_[103] = g_strdup ("42"), _tmp2_[104] = g_strdup ("Format"), _tmp2_);
	self->lexer_styles_length1 = 35;
	self->lexer_styles_length2 = 3;
}


static void gtk_perl_lexer_finalize (GObject* obj) {
	GtkPerlLexer * self;
	self = GTK_PERL_LEXER (obj);
	self->lexer_properties = (_vala_array_free (self->lexer_properties, self->lexer_properties_length1 * self->lexer_properties_length2, (GDestroyNotify) g_free), NULL);
	self->lexer_keywords = (_vala_array_free (self->lexer_keywords, self->lexer_keywords_length1 * self->lexer_keywords_length2, (GDestroyNotify) g_free), NULL);
	self->lexer_styles = (_vala_array_free (self->lexer_styles, self->lexer_styles_length1 * self->lexer_styles_length2, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (gtk_perl_lexer_parent_class)->finalize (obj);
}


GType gtk_perl_lexer_get_type (void) {
	static volatile gsize gtk_perl_lexer_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_perl_lexer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GtkPerlLexerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gtk_perl_lexer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GtkPerlLexer), 0, (GInstanceInitFunc) gtk_perl_lexer_instance_init, NULL };
		static const GInterfaceInfo gtk_ieditor_lexer_info = { (GInterfaceInitFunc) gtk_perl_lexer_gtk_ieditor_lexer_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gtk_perl_lexer_type_id;
		gtk_perl_lexer_type_id = g_type_register_static (G_TYPE_OBJECT, "GtkPerlLexer", &g_define_type_info, 0);
		g_type_add_interface_static (gtk_perl_lexer_type_id, GTK_TYPE_IEDITOR_LEXER, &gtk_ieditor_lexer_info);
		g_once_init_leave (&gtk_perl_lexer_type_id__volatile, gtk_perl_lexer_type_id);
	}
	return gtk_perl_lexer_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




