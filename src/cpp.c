/* cpp.c generated by valac 0.10.0, the Vala compiler
 * generated from cpp.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "gtkeditor.h"
#include <stdlib.h>
#include <string.h>
#include <Scintilla.h>
#include <SciLexer.h>
#include <ScintillaWidget.h>
#include <glib/gstdio.h>
#include <stdio.h>

#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))


static gpointer gtk_cpp_lexer_parent_class = NULL;
static GtkIEditorLexerIface* gtk_cpp_lexer_gtk_ieditor_lexer_parent_iface = NULL;

enum  {
	GTK_CPP_LEXER_DUMMY_PROPERTY,
	GTK_CPP_LEXER_STYLING_WITHIN_PREPROCESSOR,
	GTK_CPP_LEXER_ALLOW_DOLLARS,
	GTK_CPP_LEXER_TRACK_PREPROCESSOR,
	GTK_CPP_LEXER_UPDATE_PREPROCESSOR,
	GTK_CPP_LEXER_FOLD,
	GTK_CPP_LEXER_FOLD_COMMENT,
	GTK_CPP_LEXER_FOLD_COMMENT_EXPLICIT,
	GTK_CPP_LEXER_FOLD_PREPROCESSOR,
	GTK_CPP_LEXER_FOLD_COMPACT,
	GTK_CPP_LEXER_FOLD_AT_ELSE
};
static gboolean gtk_cpp_lexer_real_write_config (GtkIEditorLexer* base, const char* filename);
static gboolean gtk_cpp_lexer_real_read_config (GtkIEditorLexer* base, const char* filename);
static char** gtk_cpp_lexer_real_list_props (GtkIEditorLexer* base, int* result_length1);
static void _vala_array_add1 (char*** array, int* length, int* size, char* value);
static gboolean gtk_cpp_lexer_real_has_prop (GtkIEditorLexer* base, const char* propname);
static gboolean gtk_cpp_lexer_real_get_prop_as_int (GtkIEditorLexer* base, const char* propname, gint* propvalue);
static gboolean gtk_cpp_lexer_real_get_prop_as_bool (GtkIEditorLexer* base, const char* propname, gboolean* propvalue);
static gboolean gtk_cpp_lexer_real_get_prop_as_string (GtkIEditorLexer* base, const char* propname, char** propvalue);
static char* gtk_cpp_lexer_real_get_prop (GtkIEditorLexer* base, const char* propname);
static gboolean gtk_cpp_lexer_real_set_prop (GtkIEditorLexer* base, const char* propname, const char* propvalue);
static void gtk_cpp_lexer_finalize (GObject* obj);
static void gtk_cpp_lexer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void gtk_cpp_lexer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static int _vala_strcmp0 (const char * str1, const char * str2);



GtkCppLexer* gtk_cpp_lexer_construct (GType object_type, ScintillaObject* sci) {
	GtkCppLexer * self;
	self = (GtkCppLexer*) g_object_new (object_type, NULL);
	self->sci = sci;
	scintilla_send_message (self->sci, (unsigned int) SCI_SETLEXER, (uptr_t) ((gulong) GTK_CPP_LEXER_lexer_index), (sptr_t) ((glong) 0));
	return self;
}


GtkCppLexer* gtk_cpp_lexer_new (ScintillaObject* sci) {
	return gtk_cpp_lexer_construct (GTK_TYPE_CPP_LEXER, sci);
}


static gboolean gtk_cpp_lexer_real_write_config (GtkIEditorLexer* base, const char* filename) {
	GtkCppLexer * self;
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	self = (GtkCppLexer*) base;
	g_return_val_if_fail (filename != NULL, FALSE);
	{
		GKeyFile* kf;
		char* data;
		kf = g_key_file_new ();
		g_key_file_set_integer (kf, "LEXER", "LEXER_ID", GTK_CPP_LEXER_lexer_index);
		g_key_file_set_comment (kf, "LEXER", "LEXER_ID", "Do not change LEXER_ID or LEXER_NAME", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch1_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch1_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		g_key_file_set_string (kf, "LEXER", "LEXER_NAME", GTK_CPP_LEXER_lexer_name);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp0_;
				_tmp0_ = TRUE;
				while (TRUE) {
					char* config_prop_name;
					char* lexer_prop_name;
					char* lexer_prop_type;
					char* comment;
					const char* _tmp3_;
					GQuark _tmp4_;
					static GQuark _tmp4__label0 = 0;
					static GQuark _tmp4__label1 = 0;
					if (!_tmp0_) {
						i++;
					}
					_tmp0_ = FALSE;
					if (!(i < self->lexer_properties_length1)) {
						break;
					}
					config_prop_name = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 0]);
					lexer_prop_name = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 1]);
					lexer_prop_type = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 2]);
					comment = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 3]);
					_tmp3_ = lexer_prop_type;
					_tmp4_ = (NULL == _tmp3_) ? 0 : g_quark_from_string (_tmp3_);
					if (_tmp4_ == ((0 != _tmp4__label0) ? _tmp4__label0 : (_tmp4__label0 = g_quark_from_static_string ("bool"))))
					switch (0) {
						default:
						{
							gboolean prop_val = FALSE;
							gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, lexer_prop_name, &prop_val);
							g_key_file_set_boolean (kf, "LEXER", config_prop_name, prop_val);
							break;
						}
					} else if (_tmp4_ == ((0 != _tmp4__label1) ? _tmp4__label1 : (_tmp4__label1 = g_quark_from_static_string ("int"))))
					switch (0) {
						default:
						{
							gint prop_val = 0;
							gtk_ieditor_lexer_get_prop_as_int ((GtkIEditorLexer*) self, lexer_prop_name, &prop_val);
							g_key_file_set_integer (kf, "LEXER", config_prop_name, prop_val);
							break;
						}
					} else
					switch (0) {
						default:
						{
							char* prop_val;
							char* _tmp1_ = NULL;
							char* _tmp2_;
							prop_val = NULL;
							gtk_ieditor_lexer_get_prop_as_string ((GtkIEditorLexer*) self, lexer_prop_name, &_tmp1_);
							prop_val = (_tmp2_ = _tmp1_, _g_free0 (prop_val), _tmp2_);
							g_key_file_set_string (kf, "LEXER", config_prop_name, prop_val);
							_g_free0 (prop_val);
							break;
						}
					}
					g_key_file_set_comment (kf, "LEXER", config_prop_name, comment, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (comment);
						_g_free0 (lexer_prop_type);
						_g_free0 (lexer_prop_name);
						_g_free0 (config_prop_name);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch1_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch1_g_file_error;
						}
						_g_free0 (comment);
						_g_free0 (lexer_prop_type);
						_g_free0 (lexer_prop_name);
						_g_free0 (config_prop_name);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					_g_free0 (comment);
					_g_free0 (lexer_prop_type);
					_g_free0 (lexer_prop_name);
					_g_free0 (config_prop_name);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp5_;
				_tmp5_ = TRUE;
				while (TRUE) {
					char* comment;
					char* keywords;
					char* keyname;
					if (!_tmp5_) {
						i++;
					}
					_tmp5_ = FALSE;
					if (!(i < self->lexer_keywords_length1)) {
						break;
					}
					comment = g_strdup (self->lexer_keywords[(i * self->lexer_keywords_length2) + 0]);
					keywords = g_strdup (self->lexer_keywords[(i * self->lexer_keywords_length2) + 1]);
					keyname = g_strdup_printf ("KEYWORDS_%d", i);
					g_key_file_set_string (kf, "KEYWORDS", keyname, keywords);
					g_key_file_set_comment (kf, "KEYWORDS", keyname, comment, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (keyname);
						_g_free0 (keywords);
						_g_free0 (comment);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch1_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch1_g_file_error;
						}
						_g_free0 (keyname);
						_g_free0 (keywords);
						_g_free0 (comment);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					_g_free0 (keyname);
					_g_free0 (keywords);
					_g_free0 (comment);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp6_;
				_tmp6_ = TRUE;
				while (TRUE) {
					char* name;
					gint index;
					char* keyname;
					char* comment;
					gint fg_color;
					gint bg_color;
					gboolean bold;
					gboolean italic;
					const char* _tmp7_;
					const char* _tmp8_;
					char* valstr;
					if (!_tmp6_) {
						i++;
					}
					_tmp6_ = FALSE;
					if (!(i < self->lexer_styles_length1)) {
						break;
					}
					name = g_strdup (self->lexer_styles[(i * self->lexer_styles_length2) + 0]);
					index = atoi (self->lexer_styles[(i * self->lexer_styles_length2) + 1]);
					keyname = g_strdup_printf ("STYLE_%d", index);
					comment = g_strdup (self->lexer_styles[(i * self->lexer_styles_length2) + 2]);
					fg_color = (gint) scintilla_send_message (self->sci, (unsigned int) SCI_STYLEGETFORE, (uptr_t) ((gulong) index), (sptr_t) ((glong) 0));
					bg_color = (gint) scintilla_send_message (self->sci, (unsigned int) SCI_STYLEGETBACK, (uptr_t) ((gulong) index), (sptr_t) ((glong) 0));
					bold = (gboolean) scintilla_send_message (self->sci, (unsigned int) SCI_STYLEGETBOLD, (uptr_t) ((gulong) index), (sptr_t) ((glong) 0));
					italic = (gboolean) scintilla_send_message (self->sci, (unsigned int) SCI_STYLEGETITALIC, (uptr_t) ((gulong) index), (sptr_t) ((glong) 0));
					_tmp7_ = NULL;
					if (bold) {
						_tmp7_ = "true";
					} else {
						_tmp7_ = "false";
					}
					_tmp8_ = NULL;
					if (italic) {
						_tmp8_ = "true";
					} else {
						_tmp8_ = "false";
					}
					valstr = g_strdup_printf ("0x%06x;0x%06x;%s;%s;", (guint) fg_color, (guint) bg_color, _tmp7_, _tmp8_);
					g_key_file_set_string (kf, "STYLES", keyname, valstr);
					g_key_file_set_comment (kf, "STYLES", keyname, comment, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (valstr);
						_g_free0 (comment);
						_g_free0 (keyname);
						_g_free0 (name);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch1_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch1_g_file_error;
						}
						_g_free0 (valstr);
						_g_free0 (comment);
						_g_free0 (keyname);
						_g_free0 (name);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					_g_free0 (valstr);
					_g_free0 (comment);
					_g_free0 (keyname);
					_g_free0 (name);
				}
			}
		}
		data = g_key_file_to_data (kf, NULL, NULL);
		g_file_set_contents (filename, data, -1, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (data);
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch1_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch1_g_file_error;
			}
			_g_free0 (data);
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_g_free0 (data);
		_g_key_file_free0 (kf);
	}
	goto __finally1;
	__catch1_g_key_file_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("cpp.vala:187: %s", err->message);
			result = FALSE;
			_g_error_free0 (err);
			return result;
		}
	}
	goto __finally1;
	__catch1_g_file_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("cpp.vala:191: %s", err->message);
			result = FALSE;
			_g_error_free0 (err);
			return result;
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static gboolean string_to_bool (const char* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (_vala_strcmp0 (self, "true") == 0) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}


static gboolean gtk_cpp_lexer_real_read_config (GtkIEditorLexer* base, const char* filename) {
	GtkCppLexer * self;
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	self = (GtkCppLexer*) base;
	g_return_val_if_fail (filename != NULL, FALSE);
	{
		GKeyFile* kf;
		gboolean _tmp0_;
		gint lexid;
		char* _tmp1_;
		char* _tmp2_;
		char* _tmp3_;
		char* lexname;
		kf = g_key_file_new ();
		g_key_file_load_from_file (kf, filename, G_KEY_FILE_NONE, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch2_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch2_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		if (!g_key_file_has_group (kf, "LEXER")) {
			fprintf (stdout, "Lexer section not found in config file\n");
			result = FALSE;
			_g_key_file_free0 (kf);
			return result;
		}
		_tmp0_ = g_key_file_has_key (kf, "LEXER", "LEXER_ID", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch2_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch2_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		if (!_tmp0_) {
			fprintf (stdout, "Lexer ID key not found in config file\n");
			result = FALSE;
			_g_key_file_free0 (kf);
			return result;
		}
		lexid = g_key_file_get_integer (kf, "LEXER", "LEXER_ID", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch2_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch2_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		if (lexid != GTK_CPP_LEXER_lexer_index) {
			fprintf (stdout, "Wrong config file for this lexer ID\n");
			result = FALSE;
			_g_key_file_free0 (kf);
			return result;
		}
		_tmp1_ = g_key_file_get_string (kf, "LEXER", "LEXER_NAME", &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_key_file_free0 (kf);
			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
				goto __catch2_g_key_file_error;
			}
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch2_g_file_error;
			}
			_g_key_file_free0 (kf);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		lexname = (_tmp3_ = string_strip (_tmp2_ = _tmp1_), _g_free0 (_tmp2_), _tmp3_);
		if (_vala_strcmp0 (lexname, GTK_CPP_LEXER_lexer_name) != 0) {
			fprintf (stdout, "Wrong config file for this lexer name\n");
			result = FALSE;
			_g_free0 (lexname);
			_g_key_file_free0 (kf);
			return result;
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					char* config_prop_name;
					char* lexer_prop_name;
					char* lexer_prop_type;
					char* comment;
					const char* _tmp9_;
					GQuark _tmp10_;
					static GQuark _tmp10__label0 = 0;
					static GQuark _tmp10__label1 = 0;
					if (!_tmp4_) {
						i++;
					}
					_tmp4_ = FALSE;
					if (!(i < self->lexer_properties_length1)) {
						break;
					}
					config_prop_name = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 0]);
					lexer_prop_name = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 1]);
					lexer_prop_type = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 2]);
					comment = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 3]);
					_tmp9_ = lexer_prop_type;
					_tmp10_ = (NULL == _tmp9_) ? 0 : g_quark_from_string (_tmp9_);
					if (_tmp10_ == ((0 != _tmp10__label0) ? _tmp10__label0 : (_tmp10__label0 = g_quark_from_static_string ("bool"))))
					switch (0) {
						default:
						{
							gboolean _tmp5_;
							_tmp5_ = g_key_file_has_key (kf, "LEXER", config_prop_name, &_inner_error_);
							if (_inner_error_ != NULL) {
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								if (_inner_error_->domain == G_KEY_FILE_ERROR) {
									goto __catch2_g_key_file_error;
								}
								if (_inner_error_->domain == G_FILE_ERROR) {
									goto __catch2_g_file_error;
								}
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
							if (_tmp5_) {
								gboolean val;
								const char* _tmp6_;
								char* prop_val;
								val = g_key_file_get_boolean (kf, "LEXER", config_prop_name, &_inner_error_);
								if (_inner_error_ != NULL) {
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										goto __catch2_g_key_file_error;
									}
									if (_inner_error_->domain == G_FILE_ERROR) {
										goto __catch2_g_file_error;
									}
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
								_tmp6_ = NULL;
								if (val) {
									_tmp6_ = "1";
								} else {
									_tmp6_ = "0";
								}
								prop_val = g_strdup (_tmp6_);
								gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, lexer_prop_name, prop_val);
								_g_free0 (prop_val);
							}
							break;
						}
					} else if (_tmp10_ == ((0 != _tmp10__label1) ? _tmp10__label1 : (_tmp10__label1 = g_quark_from_static_string ("int"))))
					switch (0) {
						default:
						{
							gboolean _tmp7_;
							_tmp7_ = g_key_file_has_key (kf, "LEXER", config_prop_name, &_inner_error_);
							if (_inner_error_ != NULL) {
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								if (_inner_error_->domain == G_KEY_FILE_ERROR) {
									goto __catch2_g_key_file_error;
								}
								if (_inner_error_->domain == G_FILE_ERROR) {
									goto __catch2_g_file_error;
								}
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
							if (_tmp7_) {
								gint val;
								char* prop_val;
								val = g_key_file_get_integer (kf, "LEXER", config_prop_name, &_inner_error_);
								if (_inner_error_ != NULL) {
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										goto __catch2_g_key_file_error;
									}
									if (_inner_error_->domain == G_FILE_ERROR) {
										goto __catch2_g_file_error;
									}
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
								prop_val = g_strdup_printf ("%i", val);
								gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, lexer_prop_name, prop_val);
								_g_free0 (prop_val);
							}
							break;
						}
					} else
					switch (0) {
						default:
						{
							gboolean _tmp8_;
							_tmp8_ = g_key_file_has_key (kf, "LEXER", config_prop_name, &_inner_error_);
							if (_inner_error_ != NULL) {
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								if (_inner_error_->domain == G_KEY_FILE_ERROR) {
									goto __catch2_g_key_file_error;
								}
								if (_inner_error_->domain == G_FILE_ERROR) {
									goto __catch2_g_file_error;
								}
								_g_free0 (comment);
								_g_free0 (lexer_prop_type);
								_g_free0 (lexer_prop_name);
								_g_free0 (config_prop_name);
								_g_free0 (lexname);
								_g_key_file_free0 (kf);
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
							if (_tmp8_) {
								char* prop_val;
								prop_val = g_key_file_get_string (kf, "LEXER", config_prop_name, &_inner_error_);
								if (_inner_error_ != NULL) {
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										goto __catch2_g_key_file_error;
									}
									if (_inner_error_->domain == G_FILE_ERROR) {
										goto __catch2_g_file_error;
									}
									_g_free0 (comment);
									_g_free0 (lexer_prop_type);
									_g_free0 (lexer_prop_name);
									_g_free0 (config_prop_name);
									_g_free0 (lexname);
									_g_key_file_free0 (kf);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
								gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, lexer_prop_name, prop_val);
								_g_free0 (prop_val);
							}
							break;
						}
					}
					_g_free0 (comment);
					_g_free0 (lexer_prop_type);
					_g_free0 (lexer_prop_name);
					_g_free0 (config_prop_name);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp11_;
				_tmp11_ = TRUE;
				while (TRUE) {
					char* keyname;
					gboolean _tmp12_;
					if (!_tmp11_) {
						i++;
					}
					_tmp11_ = FALSE;
					if (!(i < self->lexer_keywords_length1)) {
						break;
					}
					keyname = g_strdup_printf ("KEYWORDS_%d", i);
					_tmp12_ = g_key_file_has_key (kf, "KEYWORDS", keyname, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (keyname);
						_g_free0 (lexname);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch2_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch2_g_file_error;
						}
						_g_free0 (keyname);
						_g_free0 (lexname);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					if (_tmp12_) {
						char* _tmp13_;
						char* *_tmp14_;
						char* _tmp15_;
						_tmp13_ = g_key_file_get_string (kf, "KEYWORDS", keyname, &_inner_error_);
						if (_inner_error_ != NULL) {
							_g_free0 (keyname);
							_g_free0 (lexname);
							_g_key_file_free0 (kf);
							if (_inner_error_->domain == G_KEY_FILE_ERROR) {
								goto __catch2_g_key_file_error;
							}
							if (_inner_error_->domain == G_FILE_ERROR) {
								goto __catch2_g_file_error;
							}
							_g_free0 (keyname);
							_g_free0 (lexname);
							_g_key_file_free0 (kf);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
						_tmp14_ = &self->lexer_keywords[(i * self->lexer_keywords_length2) + 1];
						(*_tmp14_) = (_tmp15_ = _tmp13_, _g_free0 ((*_tmp14_)), _tmp15_);
						scintilla_send_message (self->sci, (unsigned int) SCI_SETKEYWORDS, (uptr_t) ((gulong) i), (sptr_t) ((glong) self->lexer_keywords[(i * self->lexer_keywords_length2) + 1]));
					}
					_g_free0 (keyname);
				}
			}
		}
		scintilla_send_message (self->sci, (unsigned int) SCI_STYLECLEARALL, (uptr_t) ((gulong) 0), (sptr_t) ((glong) 0));
		{
			gint i;
			i = 0;
			{
				gboolean _tmp16_;
				_tmp16_ = TRUE;
				while (TRUE) {
					gint index;
					char* keyname;
					gboolean _tmp17_;
					if (!_tmp16_) {
						i++;
					}
					_tmp16_ = FALSE;
					if (!(i < self->lexer_styles_length1)) {
						break;
					}
					index = atoi (self->lexer_styles[(i * self->lexer_styles_length2) + 1]);
					keyname = g_strdup_printf ("STYLE_%d", index);
					_tmp17_ = g_key_file_has_key (kf, "STYLES", keyname, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_free0 (keyname);
						_g_free0 (lexname);
						_g_key_file_free0 (kf);
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							goto __catch2_g_key_file_error;
						}
						if (_inner_error_->domain == G_FILE_ERROR) {
							goto __catch2_g_file_error;
						}
						_g_free0 (keyname);
						_g_free0 (lexname);
						_g_key_file_free0 (kf);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
					if (_tmp17_) {
						gint keyvalues_length1;
						gint _keyvalues_size_;
						char** _tmp19_;
						gsize _tmp18_;
						char** keyvalues;
						gint kvlen;
						keyvalues = (_tmp19_ = g_key_file_get_string_list (kf, "STYLES", keyname, &_tmp18_, &_inner_error_), keyvalues_length1 = _tmp18_, _keyvalues_size_ = keyvalues_length1, _tmp19_);
						if (_inner_error_ != NULL) {
							_g_free0 (keyname);
							_g_free0 (lexname);
							_g_key_file_free0 (kf);
							if (_inner_error_->domain == G_KEY_FILE_ERROR) {
								goto __catch2_g_key_file_error;
							}
							if (_inner_error_->domain == G_FILE_ERROR) {
								goto __catch2_g_file_error;
							}
							_g_free0 (keyname);
							_g_free0 (lexname);
							_g_key_file_free0 (kf);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
						kvlen = keyvalues_length1;
						if (kvlen > 0) {
							gint fg_color;
							fg_color = gtk_editor_style_hex_to_dec (keyvalues[0]);
							scintilla_send_message (self->sci, (unsigned int) SCI_STYLESETFORE, (uptr_t) ((gulong) index), (sptr_t) ((glong) fg_color));
						}
						if (kvlen > 1) {
							gint bg_color;
							bg_color = gtk_editor_style_hex_to_dec (keyvalues[1]);
							scintilla_send_message (self->sci, (unsigned int) SCI_STYLESETBACK, (uptr_t) ((gulong) index), (sptr_t) ((glong) bg_color));
						}
						if (kvlen > 2) {
							char* _tmp20_;
							gboolean _tmp21_;
							gboolean bold;
							bold = (_tmp21_ = string_to_bool (_tmp20_ = string_strip (keyvalues[2])), _g_free0 (_tmp20_), _tmp21_);
							scintilla_send_message (self->sci, (unsigned int) SCI_STYLESETBOLD, (uptr_t) ((gulong) index), (sptr_t) ((glong) bold));
						}
						if (kvlen > 3) {
							char* _tmp22_;
							gboolean _tmp23_;
							gboolean italic;
							italic = (_tmp23_ = string_to_bool (_tmp22_ = string_strip (keyvalues[3])), _g_free0 (_tmp22_), _tmp23_);
							scintilla_send_message (self->sci, (unsigned int) SCI_STYLESETITALIC, (uptr_t) ((gulong) index), (sptr_t) ((glong) italic));
						}
						keyvalues = (_vala_array_free (keyvalues, keyvalues_length1, (GDestroyNotify) g_free), NULL);
					}
					_g_free0 (keyname);
				}
			}
		}
		_g_free0 (lexname);
		_g_key_file_free0 (kf);
	}
	goto __finally2;
	__catch2_g_key_file_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("cpp.vala:311: %s", err->message);
			_g_error_free0 (err);
		}
	}
	goto __finally2;
	__catch2_g_file_error:
	{
		GError * err;
		err = _inner_error_;
		_inner_error_ = NULL;
		{
			g_warning ("cpp.vala:314: %s", err->message);
			_g_error_free0 (err);
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


static void _vala_array_add1 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static char** gtk_cpp_lexer_real_list_props (GtkIEditorLexer* base, int* result_length1) {
	GtkCppLexer * self;
	char** result = NULL;
	gint props_length1;
	gint _props_size_;
	char** _tmp1_;
	char** _tmp0_ = NULL;
	char** props;
	char** _tmp3_;
	self = (GtkCppLexer*) base;
	props = (_tmp1_ = (_tmp0_ = g_new0 (char*, 0 + 1), _tmp0_), props_length1 = 0, _props_size_ = props_length1, _tmp1_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				char* pname;
				gint len;
				if (!_tmp2_) {
					i++;
				}
				_tmp2_ = FALSE;
				if (!(i < self->lexer_properties_length1)) {
					break;
				}
				pname = g_strdup (self->lexer_properties[(i * self->lexer_properties_length2) + 1]);
				len = (gint) scintilla_send_message (self->sci, (unsigned int) SCI_GETPROPERTY, (uptr_t) ((gulong) pname), (sptr_t) ((glong) 0));
				if (len != 0) {
					_vala_array_add1 (&props, &props_length1, &_props_size_, g_strdup (pname));
				}
				_g_free0 (pname);
			}
		}
	}
	result = (_tmp3_ = props, *result_length1 = props_length1, _tmp3_);
	return result;
	props = (_vala_array_free (props, props_length1, (GDestroyNotify) g_free), NULL);
}


static gboolean gtk_cpp_lexer_real_has_prop (GtkIEditorLexer* base, const char* propname) {
	GtkCppLexer * self;
	gboolean result = FALSE;
	self = (GtkCppLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->lexer_properties_length1)) {
					break;
				}
				if (_vala_strcmp0 (self->lexer_properties[(i * self->lexer_properties_length2) + 1], propname) == 0) {
					result = TRUE;
					return result;
				}
			}
		}
	}
	result = FALSE;
	return result;
}


static gboolean gtk_cpp_lexer_real_get_prop_as_int (GtkIEditorLexer* base, const char* propname, gint* propvalue) {
	GtkCppLexer * self;
	gboolean result = FALSE;
	char* strval;
	self = (GtkCppLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	strval = gtk_ieditor_lexer_get_prop ((GtkIEditorLexer*) self, propname);
	if (strval != NULL) {
		*propvalue = atoi (strval);
		result = TRUE;
		_g_free0 (strval);
		return result;
	}
	result = FALSE;
	_g_free0 (strval);
	return result;
}


static gboolean gtk_cpp_lexer_real_get_prop_as_bool (GtkIEditorLexer* base, const char* propname, gboolean* propvalue) {
	GtkCppLexer * self;
	gboolean result = FALSE;
	char* strval;
	self = (GtkCppLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	strval = gtk_ieditor_lexer_get_prop ((GtkIEditorLexer*) self, propname);
	if (strval != NULL) {
		*propvalue = (gboolean) atoi (strval);
		result = TRUE;
		_g_free0 (strval);
		return result;
	}
	result = FALSE;
	_g_free0 (strval);
	return result;
}


static gboolean gtk_cpp_lexer_real_get_prop_as_string (GtkIEditorLexer* base, const char* propname, char** propvalue) {
	GtkCppLexer * self;
	gboolean result = FALSE;
	char* strval;
	self = (GtkCppLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	if (propvalue != NULL) {
		*propvalue = NULL;
	}
	strval = gtk_ieditor_lexer_get_prop ((GtkIEditorLexer*) self, propname);
	if (strval != NULL) {
		char* _tmp0_;
		*propvalue = (_tmp0_ = g_strdup (strval), _g_free0 (*propvalue), _tmp0_);
		result = TRUE;
		_g_free0 (strval);
		return result;
	}
	result = FALSE;
	_g_free0 (strval);
	return result;
}


static char* gtk_cpp_lexer_real_get_prop (GtkIEditorLexer* base, const char* propname) {
	GtkCppLexer * self;
	char* result = NULL;
	gint len;
	gchar* val;
	char* prop_value;
	self = (GtkCppLexer*) base;
	g_return_val_if_fail (propname != NULL, NULL);
	if (!gtk_ieditor_lexer_has_prop ((GtkIEditorLexer*) self, propname)) {
		result = NULL;
		return result;
	}
	len = (gint) scintilla_send_message (self->sci, (unsigned int) SCI_GETPROPERTY, (uptr_t) ((gulong) propname), (sptr_t) ((glong) 0));
	val = g_malloc0 ((gsize) (len + 1));
	scintilla_send_message (self->sci, (unsigned int) SCI_GETPROPERTY, (uptr_t) ((gulong) propname), (sptr_t) ((glong) val));
	prop_value = g_strdup ((const char*) val);
	g_free (val);
	result = prop_value;
	return result;
}


static gboolean gtk_cpp_lexer_real_set_prop (GtkIEditorLexer* base, const char* propname, const char* propvalue) {
	GtkCppLexer * self;
	gboolean result = FALSE;
	char* _tmp0_;
	gboolean _tmp1_;
	self = (GtkCppLexer*) base;
	g_return_val_if_fail (propname != NULL, FALSE);
	g_return_val_if_fail (propvalue != NULL, FALSE);
	if (!gtk_ieditor_lexer_has_prop ((GtkIEditorLexer*) self, propname)) {
		result = FALSE;
		return result;
	}
	scintilla_send_message (self->sci, (unsigned int) SCI_SETPROPERTY, (uptr_t) ((gulong) propname), (sptr_t) ((glong) propvalue));
	result = (_tmp1_ = _vala_strcmp0 (_tmp0_ = gtk_ieditor_lexer_get_prop ((GtkIEditorLexer*) self, propname), propvalue) == 0, _g_free0 (_tmp0_), _tmp1_);
	return result;
}


gboolean gtk_cpp_lexer_get_styling_within_preprocessor (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "styling.within.preprocessor", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_styling_within_preprocessor (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "styling.within.preprocessor", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "styling-within-preprocessor");
}


gboolean gtk_cpp_lexer_get_allow_dollars (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "lexer.cpp.allow.dollars", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_allow_dollars (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "lexer.cpp.allow.dollars", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "allow-dollars");
}


gboolean gtk_cpp_lexer_get_track_preprocessor (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "lexer.cpp.track.preprocessor", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_track_preprocessor (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "lexer.cpp.track.preprocessor", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "track-preprocessor");
}


gboolean gtk_cpp_lexer_get_update_preprocessor (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "lexer.cpp.update.preprocessor", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_update_preprocessor (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "lexer.cpp.update.preprocessor", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "update-preprocessor");
}


gboolean gtk_cpp_lexer_get_fold (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "fold", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_fold (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "fold", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "fold");
}


gboolean gtk_cpp_lexer_get_fold_comment (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "fold.comment", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_fold_comment (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "fold.comment", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "fold-comment");
}


gboolean gtk_cpp_lexer_get_fold_comment_explicit (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "fold.cpp.comment.explicit", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_fold_comment_explicit (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "fold.cpp.comment.explicit", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "fold-comment-explicit");
}


gboolean gtk_cpp_lexer_get_fold_preprocessor (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "fold.preprocessor", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_fold_preprocessor (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "fold.preprocessor", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "fold-preprocessor");
}


gboolean gtk_cpp_lexer_get_fold_compact (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "fold.compact", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_fold_compact (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "fold.compact", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "fold-compact");
}


gboolean gtk_cpp_lexer_get_fold_at_else (GtkCppLexer* self) {
	gboolean result;
	gboolean ret = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_ieditor_lexer_get_prop_as_bool ((GtkIEditorLexer*) self, "fold.at.else", &ret);
	result = ret;
	return result;
}


void gtk_cpp_lexer_set_fold_at_else (GtkCppLexer* self, gboolean value) {
	const char* _tmp0_;
	char* val;
	g_return_if_fail (self != NULL);
	_tmp0_ = NULL;
	if (value) {
		_tmp0_ = "1";
	} else {
		_tmp0_ = "0";
	}
	val = g_strdup (_tmp0_);
	gtk_ieditor_lexer_set_prop ((GtkIEditorLexer*) self, "fold.at.else", val);
	_g_free0 (val);
	g_object_notify ((GObject *) self, "fold-at-else");
}


static void gtk_cpp_lexer_class_init (GtkCppLexerClass * klass) {
	gtk_cpp_lexer_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = gtk_cpp_lexer_get_property;
	G_OBJECT_CLASS (klass)->set_property = gtk_cpp_lexer_set_property;
	G_OBJECT_CLASS (klass)->finalize = gtk_cpp_lexer_finalize;
	/**
	 * CppLexer:style_within_preprocessor:
	 * 
	 * Determines whether all preprocessor code is styled in the preprocessor style 
	 * (false, the default) or only from the initial # to the # end of the command word(true).
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_STYLING_WITHIN_PREPROCESSOR, g_param_spec_boolean ("styling-within-preprocessor", "styling-within-preprocessor", "styling-within-preprocessor", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/** 
	 * CppLexer:allow_dollars:
	 * 
	 * Set to false to disallow the '$' character in identifiers.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_ALLOW_DOLLARS, g_param_spec_boolean ("allow-dollars", "allow-dollars", "allow-dollars", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * CppLexer:track_preprocessor:
	 * 
	 * Set to true to interpret #if/#else/#endif to grey out code that is not active.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_TRACK_PREPROCESSOR, g_param_spec_boolean ("track-preprocessor", "track-preprocessor", "track-preprocessor", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * CppLexer:update_preprocessor:
	 * 
	 * Set to true to update preprocessor definitions when #define found.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_UPDATE_PREPROCESSOR, g_param_spec_boolean ("update-preprocessor", "update-preprocessor", "update-preprocessor", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * CppLexer:fold:
	 * 
	 * Enable code folding.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_FOLD, g_param_spec_boolean ("fold", "fold", "fold", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/** 
	 * CppLexer:fold_comment:
	 * 
	 * This option enables folding multi-line comments and explicit fold points.  
	 * Explicit fold points allows adding extra folding by placing a //{ comment at 
	 * the start and a //} at the end of a section that should fold.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_FOLD_COMMENT, g_param_spec_boolean ("fold-comment", "fold-comment", "fold-comment", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * CppLexer:fold_comment_explicit:
	 * 
	 * Set this property to false to disable folding explicit fold points when FOLD_COMMENT=true.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_FOLD_COMMENT_EXPLICIT, g_param_spec_boolean ("fold-comment-explicit", "fold-comment-explicit", "fold-comment-explicit", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * CppLexer:fold_preprocessor:
	 * 
	 * This option enables folding preprocessor directives.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_FOLD_PREPROCESSOR, g_param_spec_boolean ("fold-preprocessor", "fold-preprocessor", "fold-preprocessor", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * CppLexer:fold_compact:
	 * 
	 * Enable folding blank lines when folding.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_FOLD_COMPACT, g_param_spec_boolean ("fold-compact", "fold-compact", "fold-compact", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	/**
	 * CppLexer:fold_at_else:
	 * 
	 * This option enables folding on a \"} else {\" line of an if statement.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), GTK_CPP_LEXER_FOLD_AT_ELSE, g_param_spec_boolean ("fold-at-else", "fold-at-else", "fold-at-else", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void gtk_cpp_lexer_gtk_ieditor_lexer_interface_init (GtkIEditorLexerIface * iface) {
	gtk_cpp_lexer_gtk_ieditor_lexer_parent_iface = g_type_interface_peek_parent (iface);
	iface->write_config = gtk_cpp_lexer_real_write_config;
	iface->read_config = gtk_cpp_lexer_real_read_config;
	iface->list_props = gtk_cpp_lexer_real_list_props;
	iface->has_prop = gtk_cpp_lexer_real_has_prop;
	iface->get_prop_as_int = gtk_cpp_lexer_real_get_prop_as_int;
	iface->get_prop_as_bool = gtk_cpp_lexer_real_get_prop_as_bool;
	iface->get_prop_as_string = gtk_cpp_lexer_real_get_prop_as_string;
	iface->get_prop = gtk_cpp_lexer_real_get_prop;
	iface->set_prop = gtk_cpp_lexer_real_set_prop;
}


static void gtk_cpp_lexer_instance_init (GtkCppLexer * self) {
	char** _tmp0_ = NULL;
	char** _tmp1_ = NULL;
	char** _tmp2_ = NULL;
	self->lexer_properties = (_tmp0_ = g_new0 (char*, (10 * 4) + 1), _tmp0_[0] = g_strdup ("STYLING_WITHIN_PREPROCESSOR"), _tmp0_[1] = g_strdup ("styling.within.preprocessor"), _tmp0_[2] = g_strdup ("bool"), _tmp0_[3] = g_strdup ("Determines whether all preprocessor code is styled in the preprocessor" \
" style (false, the default) or only from the initial # to the # end of" \
" the command word(true)."), _tmp0_[4] = g_strdup ("ALLOW_DOLLARS"), _tmp0_[5] = g_strdup ("lexer.cpp.allow.dollars"), _tmp0_[6] = g_strdup ("bool"), _tmp0_[7] = g_strdup ("Set to false to disallow the '$' character in identifiers."), _tmp0_[8] = g_strdup ("TRACK_PREPROCESSOR"), _tmp0_[9] = g_strdup ("lexer.cpp.track.preprocessor"), _tmp0_[10] = g_strdup ("bool"), _tmp0_[11] = g_strdup ("Set to true to interpret #if/#else/#endif to grey out code that is not" \
" active."), _tmp0_[12] = g_strdup ("UPDATE_PREPROCESSOR"), _tmp0_[13] = g_strdup ("lexer.cpp.update.preprocessor"), _tmp0_[14] = g_strdup ("bool"), _tmp0_[15] = g_strdup ("Set to true to update preprocessor definitions when #define found."), _tmp0_[16] = g_strdup ("FOLD"), _tmp0_[17] = g_strdup ("fold"), _tmp0_[18] = g_strdup ("bool"), _tmp0_[19] = g_strdup ("Enable code folding."), _tmp0_[20] = g_strdup ("FOLD_COMMENT"), _tmp0_[21] = g_strdup ("fold.comment"), _tmp0_[22] = g_strdup ("bool"), _tmp0_[23] = g_strdup ("This option enables folding multi-line comments and explicit fold poin" \
"ts.  Explicit fold points allows adding extra folding by placing a //{" \
" comment at the start and a //} at the end of a section that should fo" \
"ld."), _tmp0_[24] = g_strdup ("FOLD_COMMENT_EXPLICIT"), _tmp0_[25] = g_strdup ("fold.cpp.comment.explicit"), _tmp0_[26] = g_strdup ("bool"), _tmp0_[27] = g_strdup ("Set this property to false to disable folding explicit fold points whe" \
"n FOLD_COMMENT=true."), _tmp0_[28] = g_strdup ("FOLD_PREPROCESSOR"), _tmp0_[29] = g_strdup ("fold.preprocessor"), _tmp0_[30] = g_strdup ("bool"), _tmp0_[31] = g_strdup ("This option enables folding preprocessor directives."), _tmp0_[32] = g_strdup ("FOLD_COMPACT"), _tmp0_[33] = g_strdup ("fold.compact"), _tmp0_[34] = g_strdup ("bool"), _tmp0_[35] = g_strdup ("Enable folding blank lines when folding."), _tmp0_[36] = g_strdup ("FOLD_AT_ELSE"), _tmp0_[37] = g_strdup ("fold.at.else"), _tmp0_[38] = g_strdup ("bool"), _tmp0_[39] = g_strdup ("This option enables folding on a \"} else {\" line of an if statement."), _tmp0_);
	self->lexer_properties_length1 = 10;
	self->lexer_properties_length2 = 4;
	self->lexer_keywords = (_tmp1_ = g_new0 (char*, (5 * 2) + 1), _tmp1_[0] = g_strdup ("Primary keywords and identifiers"), _tmp1_[1] = g_strdup (""), _tmp1_[2] = g_strdup ("Secondary keywords and identifiers"), _tmp1_[3] = g_strdup (""), _tmp1_[4] = g_strdup ("Documentation comment keywords"), _tmp1_[5] = g_strdup (""), _tmp1_[6] = g_strdup ("Global classes and typedefs"), _tmp1_[7] = g_strdup (""), _tmp1_[8] = g_strdup ("Preprocessor definitions"), _tmp1_[9] = g_strdup (""), _tmp1_);
	self->lexer_keywords_length1 = 5;
	self->lexer_keywords_length2 = 2;
	self->lexer_styles = (_tmp2_ = g_new0 (char*, (20 * 3) + 1), _tmp2_[0] = g_strdup ("DEFAULT"), _tmp2_[1] = g_strdup ("0"), _tmp2_[2] = g_strdup ("Default style"), _tmp2_[3] = g_strdup ("COMMENT"), _tmp2_[4] = g_strdup ("1"), _tmp2_[5] = g_strdup ("Comments"), _tmp2_[6] = g_strdup ("COMMENTLINE"), _tmp2_[7] = g_strdup ("2"), _tmp2_[8] = g_strdup ("Single line comments"), _tmp2_[9] = g_strdup ("COMMENTDOC"), _tmp2_[10] = g_strdup ("3"), _tmp2_[11] = g_strdup ("Documentation comments"), _tmp2_[12] = g_strdup ("NUMBER"), _tmp2_[13] = g_strdup ("4"), _tmp2_[14] = g_strdup ("Numbers"), _tmp2_[15] = g_strdup ("WORD"), _tmp2_[16] = g_strdup ("5"), _tmp2_[17] = g_strdup ("Primary keywords and identifiers (first set of keywords)"), _tmp2_[18] = g_strdup ("STRING"), _tmp2_[19] = g_strdup ("6"), _tmp2_[20] = g_strdup ("String literals"), _tmp2_[21] = g_strdup ("CHARACTER"), _tmp2_[22] = g_strdup ("7"), _tmp2_[23] = g_strdup ("Character literals"), _tmp2_[24] = g_strdup ("UUID"), _tmp2_[25] = g_strdup ("8"), _tmp2_[26] = g_strdup ("Universally unique identifiers"), _tmp2_[27] = g_strdup ("PREPROCESSOR"), _tmp2_[28] = g_strdup ("9"), _tmp2_[29] = g_strdup ("Preprocessor macros (fifth set of keywords)"), _tmp2_[30] = g_strdup ("OPERATOR"), _tmp2_[31] = g_strdup ("10"), _tmp2_[32] = g_strdup ("Operators"), _tmp2_[33] = g_strdup ("IDENTIFIER"), _tmp2_[34] = g_strdup ("11"), _tmp2_[35] = g_strdup ("Identifiers"), _tmp2_[36] = g_strdup ("STRINGEOL"), _tmp2_[37] = g_strdup ("12"), _tmp2_[38] = g_strdup ("String literal missing closing quote"), _tmp2_[39] = g_strdup ("VERBATIM"), _tmp2_[40] = g_strdup ("13"), _tmp2_[41] = g_strdup ("Verbatim"), _tmp2_[42] = g_strdup ("REGEX"), _tmp2_[43] = g_strdup ("14"), _tmp2_[44] = g_strdup ("Regular expressions"), _tmp2_[45] = g_strdup ("COMMENTLINEDOC"), _tmp2_[46] = g_strdup ("15"), _tmp2_[47] = g_strdup ("Single line documentation comments"), _tmp2_[48] = g_strdup ("WORD2"), _tmp2_[49] = g_strdup ("16"), _tmp2_[50] = g_strdup ("Secondary keywords and identifiers (second set of keywords)"), _tmp2_[51] = g_strdup ("COMMENTDOCKEYWORD"), _tmp2_[52] = g_strdup ("17"), _tmp2_[53] = g_strdup ("Documentation comment keyword (third set of keywords)"), _tmp2_[54] = g_strdup ("COMMENTDOCKEYWORDERROR"), _tmp2_[55] = g_strdup ("18"), _tmp2_[56] = g_strdup ("Documentation comment keyword error"), _tmp2_[57] = g_strdup ("GLOBALCLASS"), _tmp2_[58] = g_strdup ("19"), _tmp2_[59] = g_strdup ("Global classes and typedefs (fourth set of keywords)"), _tmp2_);
	self->lexer_styles_length1 = 20;
	self->lexer_styles_length2 = 3;
}


static void gtk_cpp_lexer_finalize (GObject* obj) {
	GtkCppLexer * self;
	self = GTK_CPP_LEXER (obj);
	self->lexer_properties = (_vala_array_free (self->lexer_properties, self->lexer_properties_length1 * self->lexer_properties_length2, (GDestroyNotify) g_free), NULL);
	self->lexer_keywords = (_vala_array_free (self->lexer_keywords, self->lexer_keywords_length1 * self->lexer_keywords_length2, (GDestroyNotify) g_free), NULL);
	self->lexer_styles = (_vala_array_free (self->lexer_styles, self->lexer_styles_length1 * self->lexer_styles_length2, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (gtk_cpp_lexer_parent_class)->finalize (obj);
}


GType gtk_cpp_lexer_get_type (void) {
	static volatile gsize gtk_cpp_lexer_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_cpp_lexer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GtkCppLexerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gtk_cpp_lexer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GtkCppLexer), 0, (GInstanceInitFunc) gtk_cpp_lexer_instance_init, NULL };
		static const GInterfaceInfo gtk_ieditor_lexer_info = { (GInterfaceInitFunc) gtk_cpp_lexer_gtk_ieditor_lexer_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gtk_cpp_lexer_type_id;
		gtk_cpp_lexer_type_id = g_type_register_static (G_TYPE_OBJECT, "GtkCppLexer", &g_define_type_info, 0);
		g_type_add_interface_static (gtk_cpp_lexer_type_id, GTK_TYPE_IEDITOR_LEXER, &gtk_ieditor_lexer_info);
		g_once_init_leave (&gtk_cpp_lexer_type_id__volatile, gtk_cpp_lexer_type_id);
	}
	return gtk_cpp_lexer_type_id__volatile;
}


static void gtk_cpp_lexer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GtkCppLexer * self;
	self = GTK_CPP_LEXER (object);
	switch (property_id) {
		case GTK_CPP_LEXER_STYLING_WITHIN_PREPROCESSOR:
		g_value_set_boolean (value, gtk_cpp_lexer_get_styling_within_preprocessor (self));
		break;
		case GTK_CPP_LEXER_ALLOW_DOLLARS:
		g_value_set_boolean (value, gtk_cpp_lexer_get_allow_dollars (self));
		break;
		case GTK_CPP_LEXER_TRACK_PREPROCESSOR:
		g_value_set_boolean (value, gtk_cpp_lexer_get_track_preprocessor (self));
		break;
		case GTK_CPP_LEXER_UPDATE_PREPROCESSOR:
		g_value_set_boolean (value, gtk_cpp_lexer_get_update_preprocessor (self));
		break;
		case GTK_CPP_LEXER_FOLD:
		g_value_set_boolean (value, gtk_cpp_lexer_get_fold (self));
		break;
		case GTK_CPP_LEXER_FOLD_COMMENT:
		g_value_set_boolean (value, gtk_cpp_lexer_get_fold_comment (self));
		break;
		case GTK_CPP_LEXER_FOLD_COMMENT_EXPLICIT:
		g_value_set_boolean (value, gtk_cpp_lexer_get_fold_comment_explicit (self));
		break;
		case GTK_CPP_LEXER_FOLD_PREPROCESSOR:
		g_value_set_boolean (value, gtk_cpp_lexer_get_fold_preprocessor (self));
		break;
		case GTK_CPP_LEXER_FOLD_COMPACT:
		g_value_set_boolean (value, gtk_cpp_lexer_get_fold_compact (self));
		break;
		case GTK_CPP_LEXER_FOLD_AT_ELSE:
		g_value_set_boolean (value, gtk_cpp_lexer_get_fold_at_else (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void gtk_cpp_lexer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GtkCppLexer * self;
	self = GTK_CPP_LEXER (object);
	switch (property_id) {
		case GTK_CPP_LEXER_STYLING_WITHIN_PREPROCESSOR:
		gtk_cpp_lexer_set_styling_within_preprocessor (self, g_value_get_boolean (value));
		break;
		case GTK_CPP_LEXER_ALLOW_DOLLARS:
		gtk_cpp_lexer_set_allow_dollars (self, g_value_get_boolean (value));
		break;
		case GTK_CPP_LEXER_TRACK_PREPROCESSOR:
		gtk_cpp_lexer_set_track_preprocessor (self, g_value_get_boolean (value));
		break;
		case GTK_CPP_LEXER_UPDATE_PREPROCESSOR:
		gtk_cpp_lexer_set_update_preprocessor (self, g_value_get_boolean (value));
		break;
		case GTK_CPP_LEXER_FOLD:
		gtk_cpp_lexer_set_fold (self, g_value_get_boolean (value));
		break;
		case GTK_CPP_LEXER_FOLD_COMMENT:
		gtk_cpp_lexer_set_fold_comment (self, g_value_get_boolean (value));
		break;
		case GTK_CPP_LEXER_FOLD_COMMENT_EXPLICIT:
		gtk_cpp_lexer_set_fold_comment_explicit (self, g_value_get_boolean (value));
		break;
		case GTK_CPP_LEXER_FOLD_PREPROCESSOR:
		gtk_cpp_lexer_set_fold_preprocessor (self, g_value_get_boolean (value));
		break;
		case GTK_CPP_LEXER_FOLD_COMPACT:
		gtk_cpp_lexer_set_fold_compact (self, g_value_get_boolean (value));
		break;
		case GTK_CPP_LEXER_FOLD_AT_ELSE:
		gtk_cpp_lexer_set_fold_at_else (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




