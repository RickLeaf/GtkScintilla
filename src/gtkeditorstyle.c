/* gtkeditorstyle.c generated by valac 0.10.0, the Vala compiler
 * generated from gtkeditorstyle.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "gtkeditor.h"
#include <stdlib.h>
#include <string.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))



static gint gtk_editor_style_single_hex_to_dec (gchar single_hex);



static gint gtk_editor_style_single_hex_to_dec (gchar single_hex) {
	gint result = 0;
	switch (single_hex) {
		case '0':
		{
			result = 0;
			return result;
		}
		case '1':
		{
			result = 1;
			return result;
		}
		case '2':
		{
			result = 2;
			return result;
		}
		case '3':
		{
			result = 3;
			return result;
		}
		case '4':
		{
			result = 4;
			return result;
		}
		case '5':
		{
			result = 5;
			return result;
		}
		case '6':
		{
			result = 6;
			return result;
		}
		case '7':
		{
			result = 7;
			return result;
		}
		case '8':
		{
			result = 8;
			return result;
		}
		case '9':
		{
			result = 9;
			return result;
		}
		case 'a':
		{
			result = 10;
			return result;
		}
		case 'b':
		{
			result = 11;
			return result;
		}
		case 'c':
		{
			result = 12;
			return result;
		}
		case 'd':
		{
			result = 13;
			return result;
		}
		case 'e':
		{
			result = 14;
			return result;
		}
		case 'f':
		{
			result = 15;
			return result;
		}
		default:
		{
			result = -1;
			return result;
		}
	}
}


static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static char* string_replace (const char* self, const char* old, const char* replacement) {
	char* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		char* _tmp0_;
		GRegex* _tmp1_;
		GRegex* regex;
		char* _tmp2_;
		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp2_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp2_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_assert_not_reached ();
			_g_error_free0 (e);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


static char* string_substring (const char* self, glong offset, glong len) {
	char* result = NULL;
	glong string_length;
	const char* start;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = string_get_length (self);
	if (offset < 0) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= 0, NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < 0) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	start = g_utf8_offset_to_pointer (self, offset);
	result = g_strndup (start, ((gchar*) g_utf8_offset_to_pointer (start, len)) - ((gchar*) start));
	return result;
}


gint gtk_editor_style_hex_to_dec (const char* hex) {
	gint result = 0;
	gint decResult;
	char* _tmp0_;
	char* _tmp1_;
	char* _tmp2_;
	char* _tmp3_;
	char* hexstr;
	char* _tmp4_;
	char* _tmp5_;
	char* _tmp6_;
	char* _tmp7_;
	char* _tmp8_;
	char* newhexstr;
	g_return_val_if_fail (hex != NULL, 0);
	decResult = 0;
	hexstr = (_tmp3_ = string_replace (_tmp2_ = string_replace (_tmp1_ = string_strip (_tmp0_ = g_utf8_strdown (hex, -1)), "0x", ""), "#", ""), _g_free0 (_tmp2_), _g_free0 (_tmp1_), _g_free0 (_tmp0_), _tmp3_);
	newhexstr = (_tmp8_ = g_strconcat (_tmp6_ = g_strconcat (_tmp4_ = string_substring (hexstr, (glong) 4, (glong) 2), _tmp5_ = string_substring (hexstr, (glong) 2, (glong) 2), NULL), _tmp7_ = string_substring (hexstr, (glong) 0, (glong) 2), NULL), _g_free0 (_tmp7_), _g_free0 (_tmp6_), _g_free0 (_tmp5_), _g_free0 (_tmp4_), _tmp8_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				gchar c;
				if (!_tmp9_) {
					i = i + 1;
				}
				_tmp9_ = FALSE;
				if (!(i < string_get_length (newhexstr))) {
					break;
				}
				c = (gchar) g_utf8_get_char (g_utf8_offset_to_pointer (newhexstr, i));
				decResult = (16 * decResult) + gtk_editor_style_single_hex_to_dec (c);
			}
		}
	}
	result = decResult;
	_g_free0 (newhexstr);
	_g_free0 (hexstr);
	return result;
}


void gtk_editor_style_copy (const GtkEditorStyle* self, GtkEditorStyle* dest) {
	dest->index = self->index;
	dest->name = g_strdup (self->name);
	dest->fg_color = self->fg_color;
	dest->bg_color = self->bg_color;
	dest->bold = self->bold;
	dest->italic = self->italic;
}


void gtk_editor_style_destroy (GtkEditorStyle* self) {
	_g_free0 (self->name);
}


GtkEditorStyle* gtk_editor_style_dup (const GtkEditorStyle* self) {
	GtkEditorStyle* dup;
	dup = g_new0 (GtkEditorStyle, 1);
	gtk_editor_style_copy (self, dup);
	return dup;
}


void gtk_editor_style_free (GtkEditorStyle* self) {
	gtk_editor_style_destroy (self);
	g_free (self);
}


GType gtk_editor_style_get_type (void) {
	static volatile gsize gtk_editor_style_type_id__volatile = 0;
	if (g_once_init_enter (&gtk_editor_style_type_id__volatile)) {
		GType gtk_editor_style_type_id;
		gtk_editor_style_type_id = g_boxed_type_register_static ("GtkEditorStyle", (GBoxedCopyFunc) gtk_editor_style_dup, (GBoxedFreeFunc) gtk_editor_style_free);
		g_once_init_leave (&gtk_editor_style_type_id__volatile, gtk_editor_style_type_id);
	}
	return gtk_editor_style_type_id__volatile;
}




