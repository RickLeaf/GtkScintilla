#!/usr/bin/env python


import os
import glob
import re
import sys
from collections import namedtuple

from ifaceproc.processor import Processor
from ifaceproc.formatter import *
from ifaceproc.lexers import write_lexers as write_lexer_headers

RE_LEX_MOD = re.compile(r"LexerModule\s+(?P<modname>[^(]+)\((?P<parms>[^)]*?)\);")

SCINTILLA_MAX_KEYWORDS = 9

lexer_mod_count = 0

class LexerModule(object):
	
	def __init__(self, **kwargs):
		self.name = kwargs.get("name", None)
		self.const = kwargs.get("const", None)
		self.color_func = kwargs.get("color_func", None)
		self.language = kwargs.get("language", None)
		self.fold_func = kwargs.get("fold_func", None)
		selfindex = kwargs.get("index", None)
		self.kw_var_name = kwargs.get("kw_var_name", None)
		if kwargs.get("filename", False):
			self.keyword_sets = get_keywords(kwargs["filename"], self.kw_var_name)
		else:
			self.keyword_sets = []
	
	def __str__(self):
		rcode = "LexerModule: %s\n" % self.name
		rcode += "    ID: %s\n" % self.const
		rcode += "    LANGUAGE: %s\n" % self.language
		rcode += "    SUPPORTS COLORING: %s\n" % self.supports_coloring
		rcode += "    SUPPORTS FOLDING: %s\n" % self.supports_folding
		rcode += "    KEYWORD SETS(%d):\n" % self.num_keyword_sets 
		cnt = 0
		for kw in self.keyword_sets:
			if kw != "NULL" and kw != "0":
				rcode += "        [%d] %s\n" % (cnt, kw)
			cnt += 1
		return rcode
	
	@property
	def num_keyword_sets(self):
		if len(self.keyword_sets) > 0 and self.keyword_sets[-1] == '0':
			return len(self.keyword_sets) - 1
		else:
			return len(self.keyword_sets)

	@property
	def supports_coloring(self):
		if self.color_func and self.color_func != "NULL" and self.color_func != "0":
			return True
		else:
			return False

	@property
	def supports_folding(self):
		if self.fold_func and self.fold_func != "NULL" and self.fold_func != "0":
			return True
		else:
			return False




def get_const_from_id(id, iface_file):
	itext = open(iface_file, "r").read()
	re_val = re.compile(r'^val\s+SCLEX_(?P<name>.+?)\s*=\s*(?P<value>.+?)\s*$')
	with open(iface_file, "r") as f:
		for line in f:
			m = re_val.match(line.strip())
			if m:
				name = m.group("name")
				try:
					index = int(m.group("value").strip())
				except ValueError as e:
					continue
				if index == id: return name
	return -1



def get_id_from_const(lex, iface_file):
	itext = open(iface_file, "r").read()
	re_val = re.compile(r'^val\s+SCLEX_(?P<name>.+?)\s*=\s*(?P<value>.+?)\s*$')
	with open(iface_file, "r") as f:
		for line in f:
			m = re_val.match(line.strip())
			if m:
				name = m.group("name")
				
				try:
					index = int(m.group("value").strip())
				except ValueError as e:
					continue
					
				if name == lex: return index
	return -1
	
	
def get_keywords(filename, var_name):
	keywords = []
	text = open(filename, "r").read()
	matches = re.findall(r'\s+%s\s*\[\]\s*=[^{]+\{(?P<desc>[^}]+)\}'%var_name, text)
	if matches > 0:
		for match in matches:
			match = re.sub('\s+', ' ', match).strip()
			fields = [ f.strip().strip('"').strip() for f in match.split(',') if f.strip() ]
			keywords.extend(fields)
	return keywords

def get_lexer_modules(base_path, iface_file):
	modules = []
	lex_files = glob.glob(os.path.join(base_path, "Lex*.cxx"))
	for f in lex_files:
		matches = RE_LEX_MOD.findall(open(f,"r").read())
		for match_tuple in matches:
			modname = match_tuple[0].strip()
			params = match_tuple[1].strip()
			params = [ p.strip().strip('"').strip() for p in params.split(',') ]
			ps = ["name", "const", "color_func", "language", "fold_func", "kw_var_name"]
			params.insert(0, modname)
			d = dict( zip(ps, params) )
			d["filename"] = f
			mod = LexerModule(**d)
			mod.index = get_id_from_const(mod.const.replace('SCLEX_',''), iface_file)
			modules.append(mod)
	return modules

def fix_desc_casing(desc):
	new_desc = re.sub('[^a-zA-Z0-9\.,\(\)\-\/]+', ' ', desc)
	new_desc = re.sub('\s+', ' ', new_desc)
	words = [w.strip() for w in new_desc.split() if w.strip()]
	new_words = []
	for word in words:
		if word[0].islower():
			word = word[0].upper() + word[1:]
		new_words.append(word)
	return ' '.join(new_words)
		

def bool_str(b):
	if b: return "TRUE"
	else: return "FALSE"
	
def write_lexer_data(lexer_dir, hsrc_file, iface_file):
	global lexer_mod_count
	
	#get_const_from_id(0, "../data/Scintilla.iface")
	
	modules = get_lexer_modules(lexer_dir, iface_file)
	modules.sort(key=lambda m: m.index)
	lexer_mod_count = len(modules)
	max_lang = max([len(m.language) for m in modules])

	ccode = """/* This file is auto-generated, do not edit */

#ifndef GTK_SCINTILLA_LEXERS_H
#define GTK_SCINTILLA_LEXERS_H


G_BEGIN_DECLS


#include <SciLexer.h>
#include <glib.h>


"""

	# add lexer state files and header and include in here
	lexd = os.path.join(os.path.dirname(hsrc_file), "lexers")
	lexer_main = os.path.join(lexd, "lexers.h")
	with open(lexer_main,"w") as lf:
		lf.write("""/* This file is auto-generated, do not edit */

#ifndef GTK_SCINTILLA_LEXER_STATES_H
#define GTK_SCINTILLA_LEXER_STATES_H


G_BEGIN_DECLS


/* these files contain lexer states use to style keywords */
""")
		for l,f in sorted(write_lexer_headers(iface_file, lexd), key=lambda l: l[0].name.lower()):
			fn_h = os.path.join(lexd, "lex%s.h" % l.name.lower())
			lf.write("#include <lexers/%s>\n" % os.path.basename(fn_h))
		
		lf.write("""

G_END_DECLS

#endif /* GTK_SCINTILLA_LEXER_STATES_H */
""")
			
	ccode += "#include <lexers/lexers.h>"
	
	ccode += """

struct _GtkScintillaLexer {
	const gchar name[GTK_SCINTILLA_LEXER_NAME_MAX];
	const gchar language[GTK_SCINTILLA_LEXER_LANGUAGE_MAX];
	const gint lexer;
	const gboolean supports_coloring;
	const gboolean supports_folding;
	const gint n_keyword_sets;
	const gchar* keyword_sets[GTK_SCINTILLA_LEXER_KEYWORD_SETS_MAX];
};

typedef struct GtkScintillaLexer GtkScintillaLexer;


#define GTK_SCINTILLA_LEXERS_MAX %d
#define GTK_SCINTILLA_LEXER_NAME_MAX %d
#define GTK_SCINTILLA_LEXER_KEYWORD_SETS_MAX	%d

""" % (lexer_mod_count, max_lang, SCINTILLA_MAX_KEYWORDS)

	for mod in modules:
		ccode += '#define %s %s\n' % (
						mod.const.replace('SCLEX_', 'GTK_SCINTILLA_LEXER_'),
						mod.index)

	ccode += """

const GtkScintillaLexer GTK_SCINTILLA_LEXERS[] = { 

	/* 0 - Nothing placeholder, not a real lexer */
	{ NULL, 0, FALSE, FALSE, 0, 
		{\tNULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL } },

"""

	cnt = 0
	for mod in modules:
		nn = mod.language
		if len(nn)>255:
			nn = nn[:255]
		ccode += '\t/* %d - %s */\n' % (mod.index,  
						mod.const.replace('SCLEX_', 'GTK_SCINTILLA_LEXER_'))
		ccode += '\t{ "%s", %d, %s, %s, %d, \n' % (
			nn, mod.index, bool_str(mod.supports_coloring), bool_str(mod.supports_folding),
			int(mod.num_keyword_sets))
		ccode += '\t\t{\t'
		for i in range(9):
			try:
				if mod.keyword_sets[i] == "0":
					ccode += 'NULL, '
				else:
					ccode += '"%s", ' % fix_desc_casing(mod.keyword_sets[i])
			except IndexError:
				ccode += 'NULL, '
			if ccode[-6:] != 'NULL, ':
				ccode += "\n\t\t\t"
		if ccode[-4:] == '\n\t\t\t':
			ccode = ccode[:-4]
		if ccode[-2:] == ', ':
			ccode = ccode[:-2]
		ccode += ' } },\n\n'
		
		cnt += 1
	
	ccode += "\n};\n"
	ccode += """
	
G_END_DECLS

#endif /* GTK_SCINTILLA_LEXERS_H */
"""
	
	open(hsrc_file, "w").write(ccode)
				
	
if __name__ == "__main__":


	from optparse import OptionParser
	
	p = OptionParser(
			usage="Usage: %prog -H CHEADER -o LEXDIR /path/to/Scintilla.iface")

	p.add_option('-d', metavar="LEXDIR", dest="lex_dir",
		help="directory to read Scintilla lexers from")
	p.add_option('-H', metavar="CHEADER", dest="chdr_file",
		help="C header file to output code to")

	opts, args = p.parse_args()
	
	if not opts.lex_dir:
		p.error("missing lexer directory option (-d)")
	if not opts.chdr_file:
		p.error("missing C header file (-H)")
	
	if len(args) < 1:
		p.error("missing Scintilla iface file")
	if not os.path.isfile(args[0]):
		p.error("specified Scintilla iface file does not exist")
	
	write_lexer_data(opts.lex_dir, opts.chdr_file, args[0])

	print "Wrote properties from %d lexer modules to headers '%s'." % (
		lexer_mod_count, os.path.basename(opts.chdr_file))
	
	
	
	










